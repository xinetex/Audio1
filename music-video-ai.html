<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Music Video Director</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/meyda/5.6.0/meyda.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #ingredientCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
        }
        #upload-area {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border: 3px dashed rgba(102, 126, 234, 0.5);
            border-radius: 25px;
            padding: 4rem 5rem;
            text-align: center;
            pointer-events: all;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #upload-area:hover { 
            border-color: #667eea; 
            background: rgba(102, 126, 234, 0.15);
            transform: scale(1.02);
        }
        #upload-area.hidden { display: none; }
        h1 { 
            font-size: 2.5rem; 
            margin-bottom: 1rem; 
            background: linear-gradient(135deg, #667eea, #764ba2, #f093fb);
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent;
            font-weight: 800;
        }
        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 0.5rem;
        }
        .features {
            margin-top: 1.5rem;
            font-size: 0.9rem;
            opacity: 0.7;
            line-height: 1.6;
        }
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            padding: 1.5rem;
            border-radius: 25px;
            border: 1px solid rgba(102, 126, 234, 0.3);
            display: none;
            z-index: 20;
        }
        #controls.show { display: block; }
        .control-row {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1rem;
        }
        .control-row:last-child { margin-bottom: 0; }
        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
            font-weight: 600;
            white-space: nowrap;
        }
        button:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }
        button:active { transform: translateY(0); }
        button.recording { 
            background: linear-gradient(135deg, #f44336, #e91e63);
            animation: pulse 1.5s ease-in-out infinite;
        }
        @keyframes pulse { 
            0%, 100% { opacity: 1; box-shadow: 0 0 20px rgba(244, 67, 54, 0.5); } 
            50% { opacity: 0.8; box-shadow: 0 0 40px rgba(244, 67, 54, 0.8); } 
        }
        .slider-group {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .slider-group label {
            min-width: 120px;
            font-size: 0.85rem;
            opacity: 0.9;
        }
        input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.3), rgba(240, 147, 251, 0.3));
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #f093fb);
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.6);
            transition: all 0.2s;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        .value {
            min-width: 40px;
            text-align: right;
            font-size: 0.85rem;
            opacity: 0.8;
            font-weight: 600;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #667eea;
        }
        select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 10px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        select:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        #analysisPanel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            padding: 1.5rem;
            border-radius: 20px;
            border: 1px solid rgba(102, 126, 234, 0.3);
            z-index: 25;
            max-width: 320px;
            display: none;
        }
        #analysisPanel.show { display: block; }
        #analysisPanel h3 {
            font-size: 1.1rem;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #667eea, #f093fb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700;
        }
        .analysis-item {
            margin-bottom: 0.75rem;
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
        .analysis-label {
            opacity: 0.7;
        }
        .analysis-value {
            font-weight: 600;
            color: #667eea;
        }
        #sceneInfo {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            padding: 1rem 1.5rem;
            border-radius: 20px;
            border: 1px solid rgba(102, 126, 234, 0.3);
            z-index: 25;
            text-align: center;
            display: none;
        }
        #sceneInfo.show { display: block; }
        #sceneTitle {
            font-size: 1.2rem;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea, #f093fb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }
        #sceneDesc {
            font-size: 0.85rem;
            opacity: 0.7;
        }
        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 0.5rem;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #f093fb);
            width: 0%;
            transition: width 0.3s ease;
        }
        #ingredientPanel {
            position: fixed;
            bottom: 180px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            padding: 1rem;
            border-radius: 20px;
            border: 1px solid rgba(102, 126, 234, 0.3);
            z-index: 25;
            max-width: 280px;
            display: none;
        }
        #ingredientPanel.show { display: block; }
        #ingredientPanel h3 {
            font-size: 1rem;
            margin-bottom: 0.75rem;
            background: linear-gradient(135deg, #667eea, #f093fb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700;
        }
        #ingredientList {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            max-height: 180px;
            overflow-y: auto;
        }
        .ingredient-item {
            position: relative;
            width: 60px;
            height: 60px;
            border-radius: 10px;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        .ingredient-item:hover {
            border-color: #667eea;
            transform: scale(1.1);
        }
        .ingredient-item.active {
            border-color: #f093fb;
            box-shadow: 0 0 20px rgba(240, 147, 251, 0.6);
        }
        .ingredient-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .ingredient-remove {
            position: absolute;
            top: 2px;
            right: 2px;
            background: rgba(244, 67, 54, 0.95);
            border: none;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            font-size: 12px;
            cursor: pointer;
            display: none;
            padding: 0;
            line-height: 20px;
            font-weight: bold;
        }
        .ingredient-item:hover .ingredient-remove { display: block; }
        #giphySearch {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        #giphyInput {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.5rem;
            border-radius: 8px;
            font-size: 0.85rem;
        }
        #giphyInput::placeholder { color: rgba(255, 255, 255, 0.5); }
        #giphyBtn {
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
        }
        .upload-btn {
            width: 100%;
            font-size: 0.85rem;
            padding: 0.6rem;
        }
        #visualizer {
            position: fixed;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2px;
            align-items: flex-end;
            height: 80px;
            display: none;
        }
        #visualizer.show { display: flex; }
        .freq-bar {
            width: 3px;
            background: linear-gradient(180deg, #f093fb, #667eea);
            border-radius: 2px;
            transition: height 0.1s ease;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <canvas id="ingredientCanvas"></canvas>
    
    <div id="sceneInfo">
        <div id="sceneTitle">Initializing...</div>
        <div id="sceneDesc">AI Director is analyzing your music</div>
        <div class="progress-bar">
            <div class="progress-fill" id="sceneProgress"></div>
        </div>
    </div>
    
    <div id="analysisPanel">
        <h3>üéµ Music Intelligence</h3>
        <div class="analysis-item">
            <span class="analysis-label">Tempo</span>
            <span class="analysis-value" id="tempoValue">-- BPM</span>
        </div>
        <div class="analysis-item">
            <span class="analysis-label">Key</span>
            <span class="analysis-value" id="keyValue">Detecting...</span>
        </div>
        <div class="analysis-item">
            <span class="analysis-label">Energy</span>
            <span class="analysis-value" id="energyValue">--</span>
        </div>
        <div class="analysis-item">
            <span class="analysis-label">Mood</span>
            <span class="analysis-value" id="moodValue">Analyzing...</span>
        </div>
        <div class="analysis-item">
            <span class="analysis-label">Section</span>
            <span class="analysis-value" id="sectionValue">--</span>
        </div>
    </div>
    
    <div id="ingredientPanel">
        <h3>üé® Visual Ingredients</h3>
        <div id="giphySearch">
            <input type="text" id="giphyInput" placeholder="Search GIFs...">
            <button id="giphyBtn">üîç</button>
        </div>
        <div id="ingredientList"></div>
        <button class="upload-btn" onclick="document.getElementById('ingredientFileInput').click()">
            üìÅ Upload Images/GIFs
        </button>
        <input type="file" id="ingredientFileInput" accept="image/*,.gif" multiple style="display: none;">
    </div>
    
    <div id="visualizer"></div>
    
    <div id="ui">
        <div id="upload-area">
            <h1>üé¨ AI Music Video Director</h1>
            <p class="subtitle">Upload audio and let AI create your cinematic masterpiece</p>
            <div class="features">
                ‚ú® Advanced Music Analysis ‚Ä¢ AI Scene Director<br>
                üé® Smart Visual Orchestration ‚Ä¢ Beat-Aware Ingredients<br>
                üé• Cinematic Camera Motion ‚Ä¢ Professional 4K Export
            </div>
            <input type="file" id="fileInput" accept="audio/*" style="display: none;">
        </div>
    </div>
    
    <div id="controls">
        <div class="control-row">
            <button id="playBtn">‚ñ∂Ô∏è Play</button>
            <button id="recordBtn">‚è∫Ô∏è Record</button>
            <button id="downloadBtn" style="display:none;">üíæ Download</button>
            <button id="analysisBtn">üéµ Analysis</button>
            <button id="ingredientsBtn">üé® Ingredients</button>
            <select id="directorMode">
                <option value="auto">ü§ñ Auto Director</option>
                <option value="cinematic">üé¨ Cinematic</option>
                <option value="energetic">‚ö° Energetic</option>
                <option value="ambient">üåä Ambient</option>
                <option value="psychedelic">üåÄ Psychedelic</option>
            </select>
        </div>
        <div class="control-row">
            <div class="slider-group">
                <label>üöÄ Camera Speed</label>
                <input type="range" id="cameraSpeed" min="0" max="100" value="60">
                <span class="value" id="cameraSpeedVal">60</span>
            </div>
            <div class="slider-group">
                <label>üé® Visual Intensity</label>
                <input type="range" id="intensity" min="0" max="100" value="70">
                <span class="value" id="intensityVal">70</span>
            </div>
        </div>
        <div class="control-row">
            <div class="slider-group">
                <label>üí´ Effect Complexity</label>
                <input type="range" id="complexity" min="0" max="100" value="65">
                <span class="value" id="complexityVal">65</span>
            </div>
            <div class="slider-group">
                <label>üéØ Beat Sensitivity</label>
                <input type="range" id="beatSensitivity" min="0" max="100" value="60">
                <span class="value" id="beatSensitivityVal">60</span>
            </div>
        </div>
        <div class="control-row">
            <div class="checkbox-group">
                <input type="checkbox" id="autoScenes" checked>
                <label for="autoScenes">üé¨ Auto Scene Changes</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="smartIngredients" checked>
                <label for="smartIngredients">‚ú® Smart Ingredients</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="showVisualizer">
                <label for="showVisualizer">üìä Spectrum</label>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // CORE SYSTEM INITIALIZATION
        // ============================================
        
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2', { preserveDrawingBuffer: true });
        const ingredientCanvas = document.getElementById('ingredientCanvas');
        const ctx2d = ingredientCanvas.getContext('2d');
        const uploadArea = document.getElementById('upload-area');
        const fileInput = document.getElementById('fileInput');
        const controls = document.getElementById('controls');
        const playBtn = document.getElementById('playBtn');
        const recordBtn = document.getElementById('recordBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const analysisBtn = document.getElementById('analysisBtn');
        const ingredientsBtn = document.getElementById('ingredientsBtn');
        const analysisPanel = document.getElementById('analysisPanel');
        const ingredientPanel = document.getElementById('ingredientPanel');
        const sceneInfo = document.getElementById('sceneInfo');
        const visualizer = document.getElementById('visualizer');

        let audioContext, analyser, source, audioBuffer, meydaAnalyzer;
        let isPlaying = false;
        let mediaRecorder, recordedChunks = [];
        let startTime = 0;
        let currentTime = 0;
        
        let params = {
            cameraSpeed: 0.6,
            intensity: 0.7,
            complexity: 0.65,
            beatSensitivity: 0.6
        };

        // ============================================
        // AUDIO INTELLIGENCE ENGINE
        // ============================================
        
        class AudioIntelligence {
            constructor() {
                this.features = {
                    rms: 0,
                    energy: 0,
                    spectralCentroid: 0,
                    spectralFlux: 0,
                    zcr: 0,
                    chroma: [],
                    mfcc: [],
                    loudness: 0
                };
                this.tempo = 120;
                this.key = 'C';
                this.mood = 'neutral';
                this.section = 'intro';
                this.beatHistory = [];
                this.lastBeat = 0;
                this.energyHistory = [];
                this.onsetStrength = 0;
            }

            update(meydaFeatures) {
                if (!meydaFeatures) return;
                
                // Extract features from Meyda
                this.features.rms = meydaFeatures.rms || 0;
                this.features.energy = meydaFeatures.energy || 0;
                this.features.spectralCentroid = meydaFeatures.spectralCentroid || 0;
                this.features.spectralFlux = meydaFeatures.spectralFlux || 0;
                this.features.zcr = meydaFeatures.zcr || 0;
                this.features.chroma = meydaFeatures.chroma || [];
                this.features.mfcc = meydaFeatures.mfcc || [];
                this.features.loudness = meydaFeatures.loudness?.total || 0;
                
                // Track energy over time
                this.energyHistory.push(this.features.energy);
                if (this.energyHistory.length > 100) this.energyHistory.shift();
                
                // Estimate tempo from beat intervals
                this.detectBeat();
                
                // Infer mood from spectral features
                this.analyzeMood();
                
                // Update UI
                this.updateUI();
            }

            detectBeat() {
                const now = performance.now();
                const energy = this.features.energy;
                const flux = this.features.spectralFlux;
                
                this.beatHistory.push(energy);
                if (this.beatHistory.length > 30) this.beatHistory.shift();
                
                const avg = this.beatHistory.reduce((a, b) => a + b, 0) / this.beatHistory.length;
                const threshold = avg * (1.0 + params.beatSensitivity);
                
                if (energy > threshold && now - this.lastBeat > 300) {
                    this.onsetStrength = Math.min(1.0, (energy - avg) / avg);
                    this.lastBeat = now;
                    
                    // Calculate tempo from beat intervals
                    const interval = now - (this.beatTimes?.[this.beatTimes.length - 1] || now);
                    if (interval > 200 && interval < 2000) {
                        const bpm = 60000 / interval;
                        this.tempo = Math.round(bpm * 0.3 + this.tempo * 0.7); // Smooth
                    }
                    
                    this.beatTimes = this.beatTimes || [];
                    this.beatTimes.push(now);
                    if (this.beatTimes.length > 8) this.beatTimes.shift();
                    
                    return true;
                }
                
                this.onsetStrength *= 0.9; // Decay
                return false;
            }

            analyzeMood() {
                // Simple mood inference from spectral features
                const brightness = this.features.spectralCentroid / 3000; // Normalized
                const energy = Math.min(1, this.features.energy);
                const avgEnergy = this.energyHistory.reduce((a,b) => a+b, 0) / this.energyHistory.length;
                
                if (energy > 0.7 && brightness > 0.6) {
                    this.mood = 'energetic';
                } else if (energy < 0.3 && brightness < 0.4) {
                    this.mood = 'calm';
                } else if (brightness > 0.7) {
                    this.mood = 'bright';
                } else if (energy > avgEnergy * 1.3) {
                    this.mood = 'intense';
                } else {
                    this.mood = 'balanced';
                }
                
                // Infer key from chroma (simplified)
                if (this.features.chroma && this.features.chroma.length === 12) {
                    const maxChroma = Math.max(...this.features.chroma);
                    const keyIndex = this.features.chroma.indexOf(maxChroma);
                    const keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                    this.key = keys[keyIndex] || 'C';
                }
            }

            updateSection(time, duration) {
                const progress = time / duration;
                
                if (progress < 0.15) {
                    this.section = 'intro';
                } else if (progress < 0.35) {
                    this.section = 'verse 1';
                } else if (progress < 0.45) {
                    this.section = 'pre-chorus';
                } else if (progress < 0.6) {
                    this.section = 'chorus';
                } else if (progress < 0.75) {
                    this.section = 'verse 2';
                } else if (progress < 0.85) {
                    this.section = 'bridge';
                } else {
                    this.section = 'outro';
                }
            }

            updateUI() {
                document.getElementById('tempoValue').textContent = `${this.tempo} BPM`;
                document.getElementById('keyValue').textContent = this.key;
                document.getElementById('energyValue').textContent = 
                    Math.round(this.features.energy * 100) + '%';
                document.getElementById('moodValue').textContent = 
                    this.mood.charAt(0).toUpperCase() + this.mood.slice(1);
                document.getElementById('sectionValue').textContent = this.section;
            }
        }

        const audioIntel = new AudioIntelligence();

        // ============================================
        // SCENE DIRECTOR SYSTEM
        // ============================================
        
        class SceneDirector {
            constructor() {
                this.scenes = [];
                this.currentSceneIndex = 0;
                this.transitionProgress = 0;
                this.sceneStartTime = 0;
            }

            planNarrative(duration) {
                // Create a visual story arc based on song structure
                this.scenes = [
                    {
                        name: 'üåå Cosmic Awakening',
                        description: 'Journey begins through the void',
                        shader: 0,
                        duration: duration * 0.15,
                        colorShift: 0.0,
                        intensity: 0.5,
                        cameraStyle: 'slow-zoom'
                    },
                    {
                        name: '‚ú® Energy Rising',
                        description: 'Particles gather and swirl',
                        shader: 1,
                        duration: duration * 0.20,
                        colorShift: 0.2,
                        intensity: 0.7,
                        cameraStyle: 'orbit'
                    },
                    {
                        name: 'üî• Peak Intensity',
                        description: 'Full power unleashed',
                        shader: 2,
                        duration: duration * 0.25,
                        colorShift: 0.4,
                        intensity: 0.9,
                        cameraStyle: 'dynamic'
                    },
                    {
                        name: 'üåä Fluid Transformation',
                        description: 'Morphing through dimensions',
                        shader: 3,
                        duration: duration * 0.20,
                        colorShift: 0.6,
                        intensity: 0.8,
                        cameraStyle: 'warp'
                    },
                    {
                        name: 'üéÜ Grand Finale',
                        description: 'Explosive crescendo',
                        shader: 4,
                        duration: duration * 0.15,
                        colorShift: 0.8,
                        intensity: 1.0,
                        cameraStyle: 'chaos'
                    },
                    {
                        name: 'üåô Resolution',
                        description: 'Return to stillness',
                        shader: 0,
                        duration: duration * 0.05,
                        colorShift: 0.0,
                        intensity: 0.3,
                        cameraStyle: 'slow-zoom'
                    }
                ];
            }

            update(currentTime, audioFeatures) {
                const timeInScene = currentTime - this.sceneStartTime;
                const currentScene = this.scenes[this.currentSceneIndex];
                
                if (!currentScene) return null;
                
                // Auto-advance scenes
                if (timeInScene > currentScene.duration && document.getElementById('autoScenes').checked) {
                    this.nextScene();
                }
                
                // Update scene info UI
                const progress = Math.min(1, timeInScene / currentScene.duration);
                document.getElementById('sceneTitle').textContent = currentScene.name;
                document.getElementById('sceneDesc').textContent = currentScene.description;
                document.getElementById('sceneProgress').style.width = (progress * 100) + '%';
                
                return currentScene;
            }

            nextScene() {
                this.currentSceneIndex = (this.currentSceneIndex + 1) % this.scenes.length;
                this.sceneStartTime = currentTime;
                this.transitionProgress = 1.0;
            }

            getCurrentScene() {
                return this.scenes[this.currentSceneIndex];
            }
        }

        const sceneDirector = new SceneDirector();

        // ============================================
        // SMART INGREDIENT SYSTEM
        // ============================================
        
        class SmartIngredient {
            constructor(img, config = {}) {
                this.img = img;
                this.type = config.type || 'float'; // float, explode, pulse, orbit
                this.trigger = config.trigger || 'beat'; // beat, kick, snare, hihat
                this.behaviorProfile = config.profile || 'balanced';
                this.x = Math.random() * ingredientCanvas.width;
                this.y = Math.random() * ingredientCanvas.height;
                this.size = 50 + Math.random() * 150;
                this.rotation = Math.random() * Math.PI * 2;
                this.vx = 0;
                this.vy = 0;
                this.vr = (Math.random() - 0.5) * 0.05;
                this.alpha = 1.0;
                this.scale = 0.1;
                this.life = 1.0;
                this.age = 0;
                
                this.initBehavior();
            }

            initBehavior() {
                switch(this.type) {
                    case 'explode':
                        const angle = Math.random() * Math.PI * 2;
                        const speed = 3 + Math.random() * 5;
                        this.vx = Math.cos(angle) * speed;
                        this.vy = Math.sin(angle) * speed;
                        this.vr = (Math.random() - 0.5) * 0.2;
                        break;
                    case 'float':
                        this.vx = (Math.random() - 0.5) * 2;
                        this.vy = -1 - Math.random() * 2;
                        break;
                    case 'pulse':
                        this.pulseSpeed = 2 + Math.random() * 3;
                        break;
                    case 'orbit':
                        this.orbitRadius = 100 + Math.random() * 200;
                        this.orbitSpeed = 0.02 + Math.random() * 0.03;
                        this.orbitAngle = Math.random() * Math.PI * 2;
                        this.centerX = ingredientCanvas.width / 2;
                        this.centerY = ingredientCanvas.height / 2;
                        break;
                }
            }

            update() {
                this.age++;
                this.life = Math.max(0, 1.0 - this.age / 100);
                this.alpha = this.life;
                this.scale = Math.min(1.0, this.scale + 0.08);
                
                switch(this.type) {
                    case 'explode':
                        this.x += this.vx;
                        this.y += this.vy;
                        this.vy += 0.1; // Gravity
                        this.rotation += this.vr;
                        this.vx *= 0.98;
                        this.vy *= 0.98;
                        break;
                    case 'float':
                        this.x += this.vx;
                        this.y += this.vy;
                        this.vx += (Math.random() - 0.5) * 0.1;
                        break;
                    case 'pulse':
                        const pulse = Math.sin(this.age * this.pulseSpeed * 0.1);
                        this.scale = 0.8 + pulse * 0.3;
                        break;
                    case 'orbit':
                        this.orbitAngle += this.orbitSpeed;
                        this.x = this.centerX + Math.cos(this.orbitAngle) * this.orbitRadius;
                        this.y = this.centerY + Math.sin(this.orbitAngle) * this.orbitRadius;
                        this.rotation += 0.02;
                        break;
                }
                
                return this.life > 0;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.scale(this.scale, this.scale);
                
                // Add glow effect based on behavior
                if (this.type === 'pulse') {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'rgba(102, 126, 234, 0.8)';
                }
                
                ctx.drawImage(this.img, -this.size/2, -this.size/2, this.size, this.size);
                ctx.restore();
            }
        }

        let ingredients = [];
        let activeIngredients = [];
        let spawnedIngredients = [];

        // ============================================
        // ADVANCED SHADER LIBRARY
        // ============================================
        
        const advancedShaders = [
            // 0: Cosmic Tunnel with Depth
            `precision highp float;
            uniform vec2 resolution;
            uniform float time, bass, mid, treble, zoom, colorShift, intensity;
            
            void main() {
                vec2 uv = (gl_FragCoord.xy - resolution.xy * 0.5) / resolution.y;
                float z = zoom * 5.0 + bass * 2.0;
                uv /= z;
                uv.x += time * 0.2;
                
                float angle = atan(uv.y, uv.x);
                float dist = length(uv);
                
                // Multiple tunnel layers
                float tunnel = 0.0;
                for(float i = 1.0; i <= 5.0; i++) {
                    tunnel += sin(dist * 15.0 * i - time * 2.0 * i + bass * 3.0) / i;
                    tunnel += sin(angle * 8.0 * i + time + mid * 2.0) / i;
                }
                tunnel *= intensity * 0.3;
                
                // Color based on depth
                vec3 col = vec3(
                    0.5 + sin(tunnel + colorShift * 6.28 + dist * 2.0) * 0.5,
                    0.5 + sin(tunnel + colorShift * 6.28 + 2.09) * 0.5,
                    0.5 + sin(tunnel + colorShift * 6.28 + 4.19) * 0.5
                );
                
                col *= (1.0 - dist * 0.5);
                col += bass * 0.3 * vec3(1.0, 0.5, 0.8);
                
                gl_FragColor = vec4(col, 1.0);
            }`,
            
            // 1: Particle Storm
            `precision highp float;
            uniform vec2 resolution;
            uniform float time, bass, mid, treble, zoom, colorShift, intensity;
            
            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }
            
            void main() {
                vec2 uv = (gl_FragCoord.xy - resolution.xy * 0.5) / resolution.y;
                vec3 col = vec3(0.0);
                
                float particleCount = 150.0;
                float speed = zoom * 2.0 + bass * 1.5;
                
                for(float i = 0.0; i < 150.0; i++) {
                    vec2 pos = vec2(
                        hash(vec2(i, 0.0)) - 0.5,
                        hash(vec2(i, 1.0)) - 0.5
                    ) * 2.0;
                    
                    float depth = hash(vec2(i, 2.0));
                    float t = mod(time * speed * (0.5 + depth), 10.0);
                    
                    // Spiral motion
                    float angle = t + i * 0.1;
                    float radius = t * 0.1 * depth;
                    pos += vec2(cos(angle), sin(angle)) * radius;
                    
                    // Turbulence
                    pos.x += sin(t * 3.0 + mid * 5.0) * 0.2;
                    pos.y += cos(t * 2.0 + bass * 5.0) * 0.2;
                    
                    float d = length(uv - pos);
                    float brightness = 0.005 / d * intensity;
                    brightness *= (1.0 - depth * 0.5);
                    
                    vec3 particleColor = vec3(
                        0.5 + sin(i * 0.1 + colorShift * 6.28 + time) * 0.5,
                        0.5 + sin(i * 0.13 + time * 1.3) * 0.5,
                        0.5 + sin(i * 0.17 + treble) * 0.5
                    );
                    
                    col += particleColor * brightness;
                }
                
                gl_FragColor = vec4(col, 1.0);
            }`,
            
            // 2: Fractal Energy
            `precision highp float;
            uniform vec2 resolution;
            uniform float time, bass, mid, treble, zoom, colorShift, intensity;
            
            void main() {
                vec2 uv = (gl_FragCoord.xy - resolution.xy * 0.5) / resolution.y;
                float scale = 1.0 / (zoom * 3.0 + bass);
                uv *= scale;
                uv += vec2(cos(time * 0.2) * 0.3, sin(time * 0.15) * 0.3);
                
                vec2 z = uv;
                float iter = 0.0;
                float maxIter = 64.0;
                
                for(float i = 0.0; i < 64.0; i++) {
                    if(length(z) > 4.0) break;
                    z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + uv;
                    iter = i;
                }
                
                float val = iter / maxIter * intensity;
                val += sin(time + mid * 3.0) * 0.2;
                
                vec3 col = vec3(
                    sin(val * 6.0 + colorShift * 6.28 + bass * 2.0) * 0.5 + 0.5,
                    sin(val * 6.0 + colorShift * 6.28 + 2.09 + mid) * 0.5 + 0.5,
                    sin(val * 6.0 + colorShift * 6.28 + 4.19 + treble) * 0.5 + 0.5
                );
                
                col = pow(col, vec3(1.2));
                col += bass * 0.3;
                
                gl_FragColor = vec4(col, 1.0);
            }`,
            
            // 3: Liquid Plasma
            `precision highp float;
            uniform vec2 resolution;
            uniform float time, bass, mid, treble, zoom, colorShift, intensity;
            
            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy;
                vec2 p = uv * 2.0 - 1.0;
                p.x *= resolution.x / resolution.y;
                
                float t = time * zoom * 0.5;
                
                // Layered distortion
                for(float i = 0.0; i < 5.0; i++) {
                    p.x += sin(p.y * (3.0 + i) + t + bass * 2.0) * intensity * 0.1;
                    p.y += cos(p.x * (3.0 + i) + t * 1.3 + mid * 2.0) * intensity * 0.1;
                }
                
                float len = length(p);
                vec3 col = vec3(
                    sin(len * 4.0 + t + colorShift * 6.28 + bass) * 0.5 + 0.5,
                    sin(len * 5.0 + t * 1.3 + mid) * 0.5 + 0.5,
                    sin(len * 6.0 + t * 1.7 + treble) * 0.5 + 0.5
                );
                
                col = pow(col, vec3(1.3));
                col *= (1.5 - len * 0.5);
                
                gl_FragColor = vec4(col, 1.0);
            }`,
            
            // 4: Kaleidoscope Explosion
            `precision highp float;
            uniform vec2 resolution;
            uniform float time, bass, mid, treble, zoom, colorShift, intensity;
            
            void main() {
                vec2 uv = (gl_FragCoord.xy - resolution.xy * 0.5) / resolution.y;
                uv /= (zoom * 1.5 + bass * 0.5);
                
                float dist = length(uv);
                float angle = atan(uv.y, uv.x);
                
                // Kaleidoscope segments
                float segments = 8.0 + bass * 4.0;
                angle = mod(angle, 6.28 / segments);
                angle = abs(angle - 3.14 / segments);
                angle += time * zoom + mid * 0.5;
                
                vec2 kaleido = vec2(cos(angle), sin(angle)) * dist;
                
                // Animated patterns
                float pattern = 0.0;
                pattern += sin(dist * 20.0 - time * 3.0 + bass * 5.0);
                pattern += sin(angle * 12.0 + time * 2.0 + mid * 3.0);
                pattern += sin(kaleido.x * 15.0 + kaleido.y * 15.0 + treble);
                pattern *= intensity;
                
                vec3 col = vec3(
                    sin(pattern + colorShift * 6.28) * 0.5 + 0.5,
                    sin(pattern + colorShift * 6.28 + 2.09) * 0.5 + 0.5,
                    sin(pattern + colorShift * 6.28 + 4.19) * 0.5 + 0.5
                );
                
                col *= (1.2 - dist * 0.4);
                col += bass * 0.4 * vec3(1.0, 0.7, 0.9);
                
                gl_FragColor = vec4(col, 1.0);
            }`
        ];

        // Compile shaders
        const programs = [];
        const vertexShaderSource = `attribute vec2 position; void main() { gl_Position = vec4(position, 0.0, 1.0); }`;
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);

        advancedShaders.forEach((fragSource) => {
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragSource);
            gl.compileShader(fragmentShader);
            
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(fragmentShader));
            }
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            programs.push({
                program: program,
                uniforms: {
                    resolution: gl.getUniformLocation(program, 'resolution'),
                    time: gl.getUniformLocation(program, 'time'),
                    bass: gl.getUniformLocation(program, 'bass'),
                    mid: gl.getUniformLocation(program, 'mid'),
                    treble: gl.getUniformLocation(program, 'treble'),
                    zoom: gl.getUniformLocation(program, 'zoom'),
                    colorShift: gl.getUniformLocation(program, 'colorShift'),
                    intensity: gl.getUniformLocation(program, 'intensity')
                }
            });
        });

        const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        // ============================================
        // SETUP & CONTROLS
        // ============================================
        
        function resize() {
            canvas.width = ingredientCanvas.width = window.innerWidth;
            canvas.height = ingredientCanvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            // Create visualizer bars
            const visualizerEl = document.getElementById('visualizer');
            visualizerEl.innerHTML = '';
            for (let i = 0; i < 64; i++) {
                const bar = document.createElement('div');
                bar.className = 'freq-bar';
                bar.style.height = '5px';
                visualizerEl.appendChild(bar);
            }
        }
        window.addEventListener('resize', resize);
        resize();

        // Setup sliders
        ['cameraSpeed', 'intensity', 'complexity', 'beatSensitivity'].forEach(id => {
            const slider = document.getElementById(id);
            const valueSpan = document.getElementById(id + 'Val');
            slider.addEventListener('input', (e) => {
                const val = e.target.value;
                valueSpan.textContent = val;
                const paramName = id === 'cameraSpeed' ? 'cameraSpeed' : 
                                 id === 'beatSensitivity' ? 'beatSensitivity' : id;
                params[paramName] = val / 100;
            });
        });

        // Toggle panels
        analysisBtn.addEventListener('click', () => {
            analysisPanel.classList.toggle('show');
        });
        
        ingredientsBtn.addEventListener('click', () => {
            ingredientPanel.classList.toggle('show');
        });

        document.getElementById('showVisualizer').addEventListener('change', (e) => {
            if (e.target.checked) {
                visualizer.classList.add('show');
            } else {
                visualizer.classList.remove('show');
            }
        });

        // ============================================
        // AUDIO SETUP
        // ============================================
        
        function setupAudio(arrayBuffer) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            analyser.smoothingTimeConstant = 0.8;
            
            audioContext.decodeAudioData(arrayBuffer, (buffer) => {
                audioBuffer = buffer;
                uploadArea.classList.add('hidden');
                controls.classList.add('show');
                sceneInfo.classList.add('show');
                analysisPanel.classList.add('show');
                
                // Plan the visual narrative
                sceneDirector.planNarrative(buffer.duration);
                
                // Initialize Meyda
                if (typeof Meyda !== 'undefined') {
                    meydaAnalyzer = Meyda.createMeydaAnalyzer({
                        audioContext: audioContext,
                        source: analyser,
                        bufferSize: 512,
                        featureExtractors: ['rms', 'energy', 'spectralCentroid', 'spectralFlux', 
                                           'zcr', 'chroma', 'mfcc', 'loudness'],
                        callback: (features) => {
                            audioIntel.update(features);
                        }
                    });
                }
            });
        }

        function play() {
            if (!audioBuffer) return;
            
            if (isPlaying) {
                source.stop();
                isPlaying = false;
                playBtn.textContent = '‚ñ∂Ô∏è Play';
                if (meydaAnalyzer) meydaAnalyzer.stop();
                return;
            }
            
            source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(analyser);
            analyser.connect(audioContext.destination);
            source.start();
            isPlaying = true;
            playBtn.textContent = '‚è∏Ô∏è Pause';
            startTime = audioContext.currentTime;
            
            if (meydaAnalyzer) meydaAnalyzer.start();
            
            source.onended = () => {
                isPlaying = false;
                playBtn.textContent = '‚ñ∂Ô∏è Play';
                if (meydaAnalyzer) meydaAnalyzer.stop();
            };
        }

        playBtn.addEventListener('click', play);

        // ============================================
        // INGREDIENT SYSTEM
        // ============================================
        
        const giphyInput = document.getElementById('giphyInput');
        const giphyBtn = document.getElementById('giphyBtn');
        const ingredientList = document.getElementById('ingredientList');
        const ingredientFileInput = document.getElementById('ingredientFileInput');

        giphyBtn.addEventListener('click', async () => {
            const query = giphyInput.value.trim();
            if (!query) return;
            
            try {
                const response = await fetch(
                    `https://api.giphy.com/v1/gifs/search?api_key=sXpGFDGZs0Dv1mmNFvYaGUvYwKX0PWIh&q=${encodeURIComponent(query)}&limit=10&rating=g`
                );
                const data = await response.json();
                
                data.data.forEach(gif => {
                    const url = gif.images.fixed_height_small.url;
                    addIngredient(url, gif.id);
                });
                
                giphyInput.value = '';
            } catch (err) {
                console.error('Giphy search failed:', err);
            }
        });

        giphyInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') giphyBtn.click();
        });

        ingredientFileInput.addEventListener('change', (e) => {
            Array.from(e.target.files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => addIngredient(e.target.result, file.name);
                reader.readAsDataURL(file);
            });
        });

        function addIngredient(url, id) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                const ingredient = { id, url, img };
                ingredients.push(ingredient);
                renderIngredientList();
            };
            img.src = url;
        }

        function renderIngredientList() {
            ingredientList.innerHTML = '';
            ingredients.forEach((ing, idx) => {
                const div = document.createElement('div');
                div.className = 'ingredient-item';
                if (activeIngredients.includes(ing)) div.classList.add('active');
                
                const img = document.createElement('img');
                img.src = ing.url;
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'ingredient-remove';
                removeBtn.textContent = '√ó';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    ingredients.splice(idx, 1);
                    activeIngredients = activeIngredients.filter(i => i !== ing);
                    renderIngredientList();
                };
                
                div.appendChild(img);
                div.appendChild(removeBtn);
                
                div.onclick = () => {
                    const index = activeIngredients.indexOf(ing);
                    if (index > -1) {
                        activeIngredients.splice(index, 1);
                    } else {
                        activeIngredients.push(ing);
                    }
                    renderIngredientList();
                };
                
                ingredientList.appendChild(div);
            });
        }

        function spawnSmartIngredient(type = 'random') {
            if (activeIngredients.length === 0) return;
            
            const ingredient = activeIngredients[Math.floor(Math.random() * activeIngredients.length)];
            
            // Choose behavior based on audio features
            let behaviorType = type;
            if (type === 'random') {
                const energy = audioIntel.features.energy;
                const spectralCentroid = audioIntel.features.spectralCentroid;
                
                if (energy > 0.7) {
                    behaviorType = 'explode';
                } else if (spectralCentroid > 2000) {
                    behaviorType = 'orbit';
                } else if (energy < 0.3) {
                    behaviorType = 'float';
                } else {
                    behaviorType = 'pulse';
                }
            }
            
            const smart = new SmartIngredient(ingredient.img, {
                type: behaviorType,
                trigger: 'beat'
            });
            
            smart.size = 50 + params.intensity * 200;
            spawnedIngredients.push(smart);
        }

        function updateIngredients() {
            ctx2d.clearRect(0, 0, ingredientCanvas.width, ingredientCanvas.height);
            
            spawnedIngredients = spawnedIngredients.filter(ing => {
                const alive = ing.update();
                if (alive) ing.draw(ctx2d);
                return alive;
            });
        }

        // ============================================
        // RECORDING
        // ============================================
        
        let captureStream;
        function startRecording() {
            if (!captureStream) {
                const stream1 = canvas.captureStream(60);
                const stream2 = ingredientCanvas.captureStream(60);
                captureStream = new MediaStream([
                    ...stream1.getVideoTracks(), 
                    ...stream2.getVideoTracks()
                ]);
                const audioStream = audioContext.createMediaStreamDestination();
                analyser.connect(audioStream);
                captureStream.addTrack(audioStream.stream.getAudioTracks()[0]);
            }
            
            recordedChunks = [];
            mediaRecorder = new MediaRecorder(captureStream, {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 10000000
            });
            
            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) recordedChunks.push(e.data);
            };
            
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ai-music-video-${Date.now()}.webm`;
                downloadBtn.onclick = () => a.click();
                downloadBtn.style.display = 'block';
                recordBtn.classList.remove('recording');
                recordBtn.textContent = '‚è∫Ô∏è Record';
            };
            
            mediaRecorder.start();
            recordBtn.classList.add('recording');
            recordBtn.textContent = '‚èπÔ∏è Stop Recording';
            play();
        }

        recordBtn.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            } else {
                startRecording();
            }
        });

        // ============================================
        // MAIN RENDER LOOP
        // ============================================
        
        function render() {
            // Get audio data
            const dataArray = new Uint8Array(analyser ? analyser.frequencyBinCount : 256);
            if (analyser) analyser.getByteFrequencyData(dataArray);
            
            const bass = dataArray.slice(0, 20).reduce((a, b) => a + b, 0) / 20 / 255;
            const mid = dataArray.slice(20, 100).reduce((a, b) => a + b, 0) / 80 / 255;
            const treble = dataArray.slice(100, 200).reduce((a, b) => a + b, 0) / 100 / 255;
            
            // Update time
            if (isPlaying && audioContext) {
                currentTime = audioContext.currentTime - startTime;
                audioIntel.updateSection(currentTime, audioBuffer.duration);
            }
            
            // Beat detection and ingredient spawning
            if (isPlaying && audioIntel.detectBeat()) {
                if (document.getElementById('smartIngredients').checked) {
                    spawnSmartIngredient('random');
                }
            }
            
            // Update scene director
            const currentScene = sceneDirector.update(currentTime, audioIntel.features);
            
            // Render shader
            const shaderIndex = currentScene ? currentScene.shader : 0;
            const currentProgram = programs[shaderIndex];
            
            gl.useProgram(currentProgram.program);
            
            const posLoc = gl.getAttribLocation(currentProgram.program, 'position');
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            
            const sceneColorShift = currentScene ? currentScene.colorShift : 0;
            const sceneIntensity = currentScene ? currentScene.intensity : params.intensity;
            
            gl.uniform2f(currentProgram.uniforms.resolution, canvas.width, canvas.height);
            gl.uniform1f(currentProgram.uniforms.time, performance.now() / 1000);
            gl.uniform1f(currentProgram.uniforms.bass, bass);
            gl.uniform1f(currentProgram.uniforms.mid, mid);
            gl.uniform1f(currentProgram.uniforms.treble, treble);
            gl.uniform1f(currentProgram.uniforms.zoom, params.cameraSpeed + bass * 0.3);
            gl.uniform1f(currentProgram.uniforms.colorShift, sceneColorShift);
            gl.uniform1f(currentProgram.uniforms.intensity, sceneIntensity * params.intensity);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            // Update ingredients
            updateIngredients();
            
            // Update visualizer
            const bars = document.querySelectorAll('.freq-bar');
            if (bars.length > 0 && document.getElementById('showVisualizer').checked) {
                for (let i = 0; i < bars.length; i++) {
                    const value = dataArray[i] / 255;
                    bars[i].style.height = (value * 80) + 'px';
                }
            }
            
            requestAnimationFrame(render);
        }
        render();

        // ============================================
        // FILE HANDLING
        // ============================================
        
        uploadArea.addEventListener('click', () => fileInput.click());
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) {
                const reader = new FileReader();
                reader.onload = (e) => setupAudio(e.target.result);
                reader.readAsArrayBuffer(e.target.files[0]);
            }
        });
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = '#667eea';
            uploadArea.style.transform = 'scale(1.05)';
        });
        
        uploadArea.addEventListener('dragleave', (e) => {
            uploadArea.style.borderColor = 'rgba(102, 126, 234, 0.5)';
            uploadArea.style.transform = 'scale(1)';
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = 'rgba(102, 126, 234, 0.5)';
            uploadArea.style.transform = 'scale(1)';
            const file = e.dataTransfer.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => setupAudio(e.target.result);
                reader.readAsArrayBuffer(file);
            }
        });
    </script>
</body>
</html>
