<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audiovisual with Ingredients</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #ingredientCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
        }
        #upload-area {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 2px dashed rgba(102, 126, 234, 0.4);
            border-radius: 20px;
            padding: 3rem 4rem;
            text-align: center;
            pointer-events: all;
            cursor: pointer;
            transition: all 0.3s;
        }
        #upload-area:hover { border-color: #667eea; background: rgba(102, 126, 234, 0.1); }
        #upload-area.hidden { display: none; }
        h1 { font-size: 2rem; margin-bottom: 1rem; 
             background: linear-gradient(135deg, #667eea, #764ba2);
             -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            border-radius: 20px;
            display: none;
            z-index: 20;
        }
        #controls.show { display: block; }
        .control-row {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1rem;
        }
        .control-row:last-child { margin-bottom: 0; }
        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            font-weight: 600;
            white-space: nowrap;
        }
        button:hover { transform: scale(1.05); filter: brightness(1.2); }
        button.recording { background: #f44336; animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .slider-group {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .slider-group label {
            min-width: 110px;
            font-size: 0.85rem;
            opacity: 0.9;
        }
        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.5);
        }
        .value {
            min-width: 40px;
            text-align: right;
            font-size: 0.85rem;
            opacity: 0.8;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        #ingredientPanel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 15px;
            z-index: 25;
            max-width: 250px;
            display: none;
        }
        #ingredientPanel.show { display: block; }
        #ingredientPanel h3 {
            font-size: 1rem;
            margin-bottom: 0.75rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        #ingredientList {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            max-height: 200px;
            overflow-y: auto;
        }
        .ingredient-item {
            position: relative;
            width: 60px;
            height: 60px;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        .ingredient-item:hover {
            border-color: #667eea;
            transform: scale(1.05);
        }
        .ingredient-item.active {
            border-color: #f093fb;
            box-shadow: 0 0 15px rgba(240, 147, 251, 0.5);
        }
        .ingredient-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .ingredient-remove {
            position: absolute;
            top: 2px;
            right: 2px;
            background: rgba(244, 67, 54, 0.9);
            border: none;
            color: white;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            font-size: 10px;
            cursor: pointer;
            display: none;
            padding: 0;
            line-height: 18px;
        }
        .ingredient-item:hover .ingredient-remove { display: block; }
        #giphySearch {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        #giphyInput {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.5rem;
            border-radius: 8px;
            font-size: 0.85rem;
        }
        #giphyInput::placeholder { color: rgba(255, 255, 255, 0.5); }
        #giphyBtn {
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
        }
        .upload-btn {
            width: 100%;
            font-size: 0.85rem;
            padding: 0.5rem;
        }
        #beatIndicator {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(102, 126, 234, 0.3);
            z-index: 30;
            transition: all 0.1s;
        }
        #beatIndicator.beat {
            background: rgba(102, 126, 234, 1);
            transform: scale(1.3);
            box-shadow: 0 0 30px rgba(102, 126, 234, 0.8);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <canvas id="ingredientCanvas"></canvas>
    <div id="beatIndicator"></div>
    
    <div id="ingredientPanel">
        <h3>üé® Ingredients</h3>
        <div id="giphySearch">
            <input type="text" id="giphyInput" placeholder="Search GIFs...">
            <button id="giphyBtn">üîç</button>
        </div>
        <div id="ingredientList"></div>
        <button class="upload-btn" onclick="document.getElementById('ingredientFileInput').click()">
            üìÅ Upload Images/GIFs
        </button>
        <input type="file" id="ingredientFileInput" accept="image/*,.gif" multiple style="display: none;">
    </div>
    
    <div id="ui">
        <div id="upload-area">
            <h1>üé¨ Audiovisual with Ingredients</h1>
            <p>Drop an audio file to create cinematic visuals</p>
            <p style="opacity: 0.7; margin-top: 1rem; font-size: 0.9rem;">
                Flying camera ‚Ä¢ Beat transitions ‚Ä¢ Image/GIF ingredients on beats
            </p>
            <input type="file" id="fileInput" accept="audio/*" style="display: none;">
        </div>
    </div>
    
    <div id="controls">
        <div class="control-row">
            <button id="playBtn">‚ñ∂Ô∏è Play</button>
            <button id="recordBtn">‚è∫Ô∏è Record</button>
            <button id="downloadBtn" style="display:none;">üíæ Download</button>
            <button id="ingredientsBtn">üé® Ingredients</button>
            <div class="checkbox-group">
                <input type="checkbox" id="autoCutaway" checked>
                <label for="autoCutaway">üé¨ Auto Cuts</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="ingredientsOnBeat" checked>
                <label for="ingredientsOnBeat">‚ú® Beat Spawn</label>
            </div>
        </div>
        <div class="control-row">
            <div class="slider-group">
                <label>üöÄ Zoom Speed</label>
                <input type="range" id="zoomSpeed" min="0" max="100" value="60">
                <span class="value" id="zoomSpeedVal">60</span>
            </div>
            <div class="slider-group">
                <label>üåÄ Rotation</label>
                <input type="range" id="rotation" min="0" max="100" value="40">
                <span class="value" id="rotationVal">40</span>
            </div>
        </div>
        <div class="control-row">
            <div class="slider-group">
                <label>üéØ Beat Sensitivity</label>
                <input type="range" id="beatThreshold" min="0" max="100" value="65">
                <span class="value" id="beatThresholdVal">65</span>
            </div>
            <div class="slider-group">
                <label>üí´ Ingredient Size</label>
                <input type="range" id="ingredientSize" min="10" max="100" value="40">
                <span class="value" id="ingredientSizeVal">40</span>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2', { preserveDrawingBuffer: true });
        const ingredientCanvas = document.getElementById('ingredientCanvas');
        const ctx2d = ingredientCanvas.getContext('2d');
        const uploadArea = document.getElementById('upload-area');
        const fileInput = document.getElementById('fileInput');
        const controls = document.getElementById('controls');
        const playBtn = document.getElementById('playBtn');
        const recordBtn = document.getElementById('recordBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const autoCutaway = document.getElementById('autoCutaway');
        const ingredientsOnBeat = document.getElementById('ingredientsOnBeat');
        const beatIndicator = document.getElementById('beatIndicator');
        const ingredientPanel = document.getElementById('ingredientPanel');
        const ingredientsBtn = document.getElementById('ingredientsBtn');
        const ingredientList = document.getElementById('ingredientList');
        const giphyInput = document.getElementById('giphyInput');
        const giphyBtn = document.getElementById('giphyBtn');
        const ingredientFileInput = document.getElementById('ingredientFileInput');

        let audioContext, analyser, source, audioBuffer;
        let isPlaying = false;
        let mediaRecorder, recordedChunks = [];
        let params = {
            zoomSpeed: 0.6,
            rotation: 0.4,
            beatThreshold: 0.65,
            ingredientSize: 0.4
        };

        // Ingredient system
        let ingredients = [];
        let activeIngredients = [];
        let spawnedIngredients = [];

        // Beat detection state
        let beatHistory = [];
        let lastBeatTime = 0;
        let currentScene = 0;

        // Setup sliders
        ['zoomSpeed', 'rotation', 'beatThreshold', 'ingredientSize'].forEach(id => {
            const slider = document.getElementById(id);
            const valueSpan = document.getElementById(id + 'Val');
            slider.addEventListener('input', (e) => {
                const val = e.target.value;
                valueSpan.textContent = val;
                params[id] = val / 100;
            });
        });

        // Toggle ingredient panel
        ingredientsBtn.addEventListener('click', () => {
            ingredientPanel.classList.toggle('show');
        });

        // Giphy search
        const GIPHY_API_KEY = 'YOUR_API_KEY'; // Users can add their own or use default
        giphyBtn.addEventListener('click', async () => {
            const query = giphyInput.value.trim();
            if (!query) return;
            
            try {
                // Using Giphy's public beta key for demo
                const response = await fetch(
                    `https://api.giphy.com/v1/gifs/search?api_key=sXpGFDGZs0Dv1mmNFvYaGUvYwKX0PWIh&q=${encodeURIComponent(query)}&limit=8&rating=g`
                );
                const data = await response.json();
                
                data.data.forEach(gif => {
                    const url = gif.images.fixed_height_small.url;
                    addIngredient(url, gif.id);
                });
                
                giphyInput.value = '';
            } catch (err) {
                console.error('Giphy search failed:', err);
            }
        });

        giphyInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') giphyBtn.click();
        });

        // Upload local images
        ingredientFileInput.addEventListener('change', (e) => {
            Array.from(e.target.files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => addIngredient(e.target.result, file.name);
                reader.readAsDataURL(file);
            });
        });

        // Add ingredient to library
        function addIngredient(url, id) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                const ingredient = { id, url, img };
                ingredients.push(ingredient);
                renderIngredientList();
            };
            img.src = url;
        }

        // Render ingredient library
        function renderIngredientList() {
            ingredientList.innerHTML = '';
            ingredients.forEach((ing, idx) => {
                const div = document.createElement('div');
                div.className = 'ingredient-item';
                if (activeIngredients.includes(ing)) div.classList.add('active');
                
                const img = document.createElement('img');
                img.src = ing.url;
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'ingredient-remove';
                removeBtn.textContent = '√ó';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    ingredients.splice(idx, 1);
                    activeIngredients = activeIngredients.filter(i => i !== ing);
                    renderIngredientList();
                };
                
                div.appendChild(img);
                div.appendChild(removeBtn);
                
                div.onclick = () => {
                    const index = activeIngredients.indexOf(ing);
                    if (index > -1) {
                        activeIngredients.splice(index, 1);
                    } else {
                        activeIngredients.push(ing);
                    }
                    renderIngredientList();
                };
                
                ingredientList.appendChild(div);
            });
        }

        // Spawn ingredient on beat
        function spawnIngredient() {
            if (activeIngredients.length === 0) return;
            
            const ingredient = activeIngredients[Math.floor(Math.random() * activeIngredients.length)];
            const size = 50 + params.ingredientSize * 300;
            
            spawnedIngredients.push({
                img: ingredient.img,
                x: Math.random() * ingredientCanvas.width,
                y: Math.random() * ingredientCanvas.height,
                size: size,
                rotation: Math.random() * Math.PI * 2,
                vx: (Math.random() - 0.5) * 5,
                vy: (Math.random() - 0.5) * 5,
                vr: (Math.random() - 0.5) * 0.1,
                alpha: 1.0,
                scale: 0.1,
                life: 1.0
            });
        }

        // Update and render ingredients
        function updateIngredients() {
            ctx2d.clearRect(0, 0, ingredientCanvas.width, ingredientCanvas.height);
            
            spawnedIngredients = spawnedIngredients.filter(ing => {
                ing.x += ing.vx;
                ing.y += ing.vy;
                ing.rotation += ing.vr;
                ing.life -= 0.01;
                ing.alpha = ing.life;
                ing.scale = Math.min(1.0, ing.scale + 0.1);
                
                if (ing.life <= 0) return false;
                
                ctx2d.save();
                ctx2d.globalAlpha = ing.alpha;
                ctx2d.translate(ing.x, ing.y);
                ctx2d.rotate(ing.rotation);
                ctx2d.scale(ing.scale, ing.scale);
                ctx2d.drawImage(ing.img, -ing.size/2, -ing.size/2, ing.size, ing.size);
                ctx2d.restore();
                
                return true;
            });
        }

        // Resize canvases
        function resize() {
            canvas.width = ingredientCanvas.width = window.innerWidth;
            canvas.height = ingredientCanvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // Shader scenes (same as before)
        const scenes = [
            `precision highp float;
            uniform vec2 resolution;
            uniform float time, bass, mid, treble, zoom, rotation;
            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy - 0.5;
                uv.x *= resolution.x / resolution.y;
                float z = zoom * 10.0 + bass * 3.0;
                uv /= z;
                uv += vec2(time * 0.3, 0.0);
                float angle = rotation * 3.14 + time * 0.5;
                float c = cos(angle), s = sin(angle);
                uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
                float dist = length(uv);
                float a = atan(uv.y, uv.x);
                float tunnel = sin(dist * 10.0 - time * 3.0 + bass * 5.0);
                tunnel += sin(a * 8.0 + time * 2.0 + mid * 3.0);
                vec3 col = vec3(
                    0.5 + sin(tunnel + bass) * 0.5,
                    0.5 + sin(tunnel + 2.09 + mid) * 0.5,
                    0.5 + sin(tunnel + 4.19 + treble) * 0.5
                );
                col *= (1.0 - dist * 0.3);
                col += bass * 0.4;
                gl_FragColor = vec4(col, 1.0);
            }`,
            `precision highp float;
            uniform vec2 resolution;
            uniform float time, bass, mid, treble, zoom, rotation;
            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy - 0.5;
                uv.x *= resolution.x / resolution.y;
                uv *= (2.0 - zoom);
                float dist = length(uv);
                float angle = atan(uv.y, uv.x);
                float spiral = angle + dist * 5.0 - time * rotation * 2.0;
                spiral += sin(dist * 10.0 - time * 2.0 + bass * 5.0) * 0.5;
                float arms = sin(spiral * 4.0 + bass * 2.0);
                float brightness = arms / (dist * 2.0 + 0.1);
                vec3 col = vec3(
                    brightness * (0.5 + sin(time) * 0.5),
                    brightness * (0.5 + sin(time + 2.09) * 0.5),
                    brightness * (0.5 + sin(time + 4.19) * 0.5)
                );
                gl_FragColor = vec4(col, 1.0);
            }`,
            `precision highp float;
            uniform vec2 resolution;
            uniform float time, bass, mid, treble, zoom, rotation;
            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }
            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy - 0.5;
                uv.x *= resolution.x / resolution.y;
                float angle = rotation * 3.14 + time * 0.5;
                float c = cos(angle), s = sin(angle);
                uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
                vec3 col = vec3(0.0);
                float speed = zoom * 3.0 + bass * 2.0;
                for(float i = 0.0; i < 80.0; i++) {
                    vec2 starPos = vec2(hash(vec2(i, 0.0)) - 0.5, hash(vec2(i, 1.0)) - 0.5) * 3.0;
                    float depth = hash(vec2(i, 2.0));
                    float z = mod(depth - time * speed * 0.5, 1.0);
                    vec2 pos = starPos / z;
                    float stretch = speed * (1.0 - z) * 0.3;
                    vec2 diff = uv - pos;
                    float streak = length(vec2(diff.x, diff.y / (1.0 + stretch)));
                    float brightness = 0.002 / streak * (1.0 - z);
                    col += vec3(brightness);
                }
                gl_FragColor = vec4(col, 1.0);
            }`
        ];

        // Compile shaders
        const programs = [];
        const vertexShaderSource = `attribute vec2 position; void main() { gl_Position = vec4(position, 0.0, 1.0); }`;
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);

        scenes.forEach((fragSource) => {
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragSource);
            gl.compileShader(fragmentShader);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            programs.push({
                program: program,
                uniforms: {
                    resolution: gl.getUniformLocation(program, 'resolution'),
                    time: gl.getUniformLocation(program, 'time'),
                    bass: gl.getUniformLocation(program, 'bass'),
                    mid: gl.getUniformLocation(program, 'mid'),
                    treble: gl.getUniformLocation(program, 'treble'),
                    zoom: gl.getUniformLocation(program, 'zoom'),
                    rotation: gl.getUniformLocation(program, 'rotation')
                }
            });
        });

        const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        // Audio setup
        function setupAudio(arrayBuffer) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            audioContext.decodeAudioData(arrayBuffer, (buffer) => {
                audioBuffer = buffer;
                uploadArea.classList.add('hidden');
                controls.classList.add('show');
                ingredientPanel.classList.add('show');
            });
        }

        function play() {
            if (!audioBuffer) return;
            if (isPlaying) {
                source.stop();
                isPlaying = false;
                playBtn.textContent = '‚ñ∂Ô∏è Play';
                return;
            }
            source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(analyser);
            analyser.connect(audioContext.destination);
            source.start();
            isPlaying = true;
            playBtn.textContent = '‚è∏Ô∏è Pause';
            source.onended = () => {
                isPlaying = false;
                playBtn.textContent = '‚ñ∂Ô∏è Play';
            };
        }

        // Beat detection
        function detectBeat(bass, mid) {
            const now = performance.now();
            const energy = bass * 0.7 + mid * 0.3;
            beatHistory.push(energy);
            if (beatHistory.length > 30) beatHistory.shift();
            const avg = beatHistory.reduce((a, b) => a + b, 0) / beatHistory.length;
            const threshold = avg * (1.0 + params.beatThreshold);
            if (energy > threshold && now - lastBeatTime > 300) {
                lastBeatTime = now;
                beatIndicator.classList.add('beat');
                setTimeout(() => beatIndicator.classList.remove('beat'), 100);
                if (autoCutaway.checked) {
                    currentScene = (currentScene + 1) % programs.length;
                }
                if (ingredientsOnBeat.checked) {
                    spawnIngredient();
                }
                return true;
            }
            return false;
        }

        // Recording
        let captureStream;
        function startRecording() {
            if (!captureStream) {
                const stream1 = canvas.captureStream(60);
                const stream2 = ingredientCanvas.captureStream(60);
                captureStream = new MediaStream([...stream1.getVideoTracks(), ...stream2.getVideoTracks()]);
                const audioStream = audioContext.createMediaStreamDestination();
                analyser.connect(audioStream);
                captureStream.addTrack(audioStream.stream.getAudioTracks()[0]);
            }
            recordedChunks = [];
            mediaRecorder = new MediaRecorder(captureStream, {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 8000000
            });
            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) recordedChunks.push(e.data);
            };
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `audiovisual-${Date.now()}.webm`;
                downloadBtn.onclick = () => a.click();
                downloadBtn.style.display = 'block';
                recordBtn.classList.remove('recording');
                recordBtn.textContent = '‚è∫Ô∏è Record';
            };
            mediaRecorder.start();
            recordBtn.classList.add('recording');
            recordBtn.textContent = '‚èπÔ∏è Stop';
            play();
        }

        recordBtn.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            } else {
                startRecording();
            }
        });

        // Render loop
        function render() {
            const dataArray = new Uint8Array(analyser ? analyser.frequencyBinCount : 256);
            if (analyser) analyser.getByteFrequencyData(dataArray);
            const bass = dataArray.slice(0, 20).reduce((a, b) => a + b, 0) / 20 / 255;
            const mid = dataArray.slice(20, 100).reduce((a, b) => a + b, 0) / 80 / 255;
            const treble = dataArray.slice(100, 200).reduce((a, b) => a + b, 0) / 100 / 255;
            
            if (isPlaying) detectBeat(bass, mid);
            
            const currentProgram = programs[currentScene];
            gl.useProgram(currentProgram.program);
            const posLoc = gl.getAttribLocation(currentProgram.program, 'position');
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            gl.uniform2f(currentProgram.uniforms.resolution, canvas.width, canvas.height);
            gl.uniform1f(currentProgram.uniforms.time, performance.now() / 1000);
            gl.uniform1f(currentProgram.uniforms.bass, bass);
            gl.uniform1f(currentProgram.uniforms.mid, mid);
            gl.uniform1f(currentProgram.uniforms.treble, treble);
            gl.uniform1f(currentProgram.uniforms.zoom, params.zoomSpeed + bass * 0.3);
            gl.uniform1f(currentProgram.uniforms.rotation, params.rotation);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            updateIngredients();
            requestAnimationFrame(render);
        }
        render();

        // File handling
        uploadArea.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) {
                const reader = new FileReader();
                reader.onload = (e) => setupAudio(e.target.result);
                reader.readAsArrayBuffer(e.target.files[0]);
            }
        });
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = '#667eea';
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => setupAudio(e.target.result);
                reader.readAsArrayBuffer(file);
            }
        });
        playBtn.addEventListener('click', play);
    </script>
</body>
</html>
