<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AUDIO1.TV PRO MAX - Professional Music Video Studio</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --neon-pink: #ff006e;
            --neon-blue: #00b4d8;
            --neon-purple: #7209b7;
            --neon-cyan: #00f5ff;
            --neon-green: #00ff88;
            --dark: #0a0014;
            --panel: #1a0f2e;
            --border: #2d1b4e;
        }
        
        body {
            font-family: 'SF Mono', 'Courier New', monospace;
            background: var(--dark);
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }
        
        .pro-studio {
            display: grid;
            grid-template-columns: 300px 1fr 320px;
            grid-template-rows: 80px 1fr 180px;
            height: 100vh;
            gap: 2px;
            background: var(--border);
        }
        
        /* HEADER */
        header {
            grid-column: 1/-1;
            background: linear-gradient(135deg, #1a0f2e 0%, #0a0014 100%);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 2rem;
            border-bottom: 3px solid var(--neon-purple);
            box-shadow: 0 4px 30px rgba(114,9,183,0.5);
        }
        
        .logo {
            font-size: 1.5rem;
            font-weight: 900;
            letter-spacing: 0.15em;
            background: linear-gradient(135deg, var(--neon-pink), var(--neon-cyan), var(--neon-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }
        
        .controls-bar {
            display: flex;
            gap: 0.75rem;
        }
        
        .pro-btn {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, var(--neon-purple), var(--neon-pink));
            border: 2px solid transparent;
            color: #fff;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 700;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: all 0.3s;
            box-shadow: 0 4px 20px rgba(114,9,183,0.4);
        }
        
        .pro-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(114,9,183,0.7);
        }
        
        .pro-btn.generate {
            background: linear-gradient(135deg, #00b4d8, #00f5ff);
            font-size: 1rem;
            padding: 0.9rem 2rem;
        }
        
        .stats-display {
            display: flex;
            gap: 1.5rem;
        }
        
        .stat-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5rem 1rem;
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            border: 1px solid var(--border);
        }
        
        .stat-label {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.25rem;
        }
        
        .stat-value {
            font-size: 1.2rem;
            font-weight: 900;
            color: var(--neon-cyan);
            text-shadow: 0 0 15px var(--neon-cyan);
        }
        
        /* CANVAS LAYERS */
        main {
            position: relative;
            background: #000;
            overflow: hidden;
        }
        
        canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
        }
        
        #bgCanvas { z-index: 0; }
        #canvas3d { z-index: 1; }
        #imageCanvas { z-index: 2; }
        #textCanvas { z-index: 3; }
        
        .structure-overlay {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0,0,0,0.9);
            padding: 1rem;
            border-radius: 12px;
            border: 2px solid var(--neon-cyan);
            font-size: 0.8rem;
            z-index: 10;
            backdrop-filter: blur(20px);
        }
        
        .section-badge {
            display: inline-block;
            padding: 0.4rem 0.8rem;
            background: var(--neon-purple);
            border-radius: 6px;
            margin-right: 0.5rem;
            font-weight: 700;
            font-size: 0.9rem;
        }
        
        /* TEXT TOOL */
        .text-tool {
            position: absolute;
            bottom: 200px;
            left: 20px;
            background: rgba(26,15,46,0.98);
            border: 2px solid var(--neon-cyan);
            border-radius: 12px;
            padding: 1.5rem;
            min-width: 350px;
            z-index: 50;
            display: none;
        }
        
        .text-tool.active { display: block; }
        
        .text-input {
            width: 100%;
            padding: 0.75rem;
            background: var(--dark);
            border: 1px solid var(--border);
            color: var(--neon-cyan);
            border-radius: 8px;
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }
        
        .text-effects {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .effect-btn {
            padding: 0.5rem;
            background: var(--neon-purple);
            border: none;
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 700;
            transition: all 0.2s;
        }
        
        .effect-btn:hover {
            background: var(--neon-pink);
            transform: scale(1.05);
        }
        
        .effect-btn.active {
            background: var(--neon-cyan);
            color: #000;
        }
        
        /* SIDEBAR STYLES */
        aside {
            background: var(--panel);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .panel-header {
            padding: 1rem;
            background: rgba(114,9,183,0.2);
            border-bottom: 1px solid var(--border);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-size: 0.85rem;
            color: var(--neon-cyan);
        }
        
        .asset-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            padding: 0.75rem;
            overflow-y: auto;
            flex: 1;
        }
        
        .asset {
            aspect-ratio: 1;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid var(--border);
            cursor: grab;
            transition: all 0.3s;
            position: relative;
            background: var(--dark);
        }
        
        .asset:active {
            cursor: grabbing;
        }
        
        .asset:hover {
            border-color: var(--neon-pink);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255,0,110,0.5);
        }
        
        .asset img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .asset.text-asset {
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 1.5rem;
            color: var(--neon-cyan);
            text-align: center;
            padding: 0.5rem;
        }
        
        .asset-badge {
            position: absolute;
            top: 4px;
            right: 4px;
            padding: 0.2rem 0.4rem;
            background: var(--neon-purple);
            border-radius: 4px;
            font-size: 0.6rem;
            font-weight: 700;
            text-transform: uppercase;
        }
        
        .asset-badge.character { background: var(--neon-pink); }
        .asset-badge.object { background: var(--neon-cyan); color: #000; }
        .asset-badge.text { background: var(--neon-green); color: #000; }
        
        /* SETTINGS PANEL */
        .settings-scroll {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        
        .setting {
            margin-bottom: 1.5rem;
        }
        
        .setting-title {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .slider {
            width: 100%;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: var(--border);
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--neon-pink), var(--neon-cyan));
            cursor: pointer;
            box-shadow: 0 0 10px var(--neon-cyan);
        }
        
        .setting-val {
            text-align: right;
            font-size: 0.9rem;
            color: var(--neon-cyan);
            font-weight: 700;
            margin-top: 0.25rem;
        }
        
        select {
            width: 100%;
            padding: 0.6rem;
            background: var(--dark);
            border: 1px solid var(--border);
            color: #fff;
            border-radius: 8px;
            font-family: inherit;
            cursor: pointer;
        }
        
        /* TIMELINE */
        .timeline {
            grid-column: 1/-1;
            background: var(--panel);
            display: flex;
            flex-direction: column;
            border-top: 3px solid var(--neon-purple);
        }
        
        .timeline-bar {
            padding: 0.75rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(114,9,183,0.1);
            border-bottom: 1px solid var(--border);
        }
        
        .timeline-tools {
            display: flex;
            gap: 0.5rem;
        }
        
        .tool-btn {
            padding: 0.4rem 1rem;
            background: var(--dark);
            border: 1px solid var(--border);
            color: rgba(255,255,255,0.7);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
        }
        
        .tool-btn:hover {
            border-color: var(--neon-purple);
            color: #fff;
        }
        
        .tool-btn.active {
            background: var(--neon-purple);
            color: #fff;
        }
        
        .timeline-view {
            flex: 1;
            position: relative;
            overflow-x: auto;
            overflow-y: hidden;
            background: #0d0021;
        }
        
        .timeline-drop-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.3);
            font-size: 0.9rem;
            font-weight: 700;
            pointer-events: none;
            z-index: 5;
        }
        
        #timelineCanvas {
            position: relative;
            height: 100%;
            min-width: 100%;
        }
        
        .structure-marker {
            position: absolute;
            top: 0;
            height: 100%;
            border-left: 3px solid;
            opacity: 0.6;
            pointer-events: none;
        }
        
        .structure-marker.intro { border-color: var(--neon-green); }
        .structure-marker.verse { border-color: var(--neon-blue); }
        .structure-marker.chorus { border-color: var(--neon-pink); }
        .structure-marker.bridge { border-color: var(--neon-purple); }
        .structure-marker.outro { border-color: var(--neon-cyan); }
        
        .structure-label {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0,0,0,0.8);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
        }
        
        .clip-block {
            position: absolute;
            height: 90%;
            top: 5%;
            background: linear-gradient(135deg, rgba(114,9,183,0.7), rgba(255,0,110,0.7));
            border: 2px solid var(--neon-cyan);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 700;
            color: #fff;
            overflow: hidden;
            transition: all 0.2s;
        }
        
        .clip-block:hover {
            box-shadow: 0 0 30px var(--neon-cyan);
            transform: scale(1.02);
        }
        
        .clip-block.strobe {
            background: linear-gradient(135deg, rgba(255,0,110,0.9), rgba(0,255,136,0.9));
            border-color: var(--neon-green);
        }
        
        .clip-block.text-clip {
            background: linear-gradient(135deg, rgba(0,245,255,0.7), rgba(0,180,216,0.7));
        }
        
        .playhead {
            position: absolute;
            top: 0;
            height: 100%;
            width: 3px;
            background: var(--neon-cyan);
            box-shadow: 0 0 20px var(--neon-cyan);
            z-index: 100;
            pointer-events: none;
        }
        
        .playhead::before {
            content: '‚ñº';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--neon-cyan);
            font-size: 1.2rem;
        }
        
        /* UPLOAD SCREEN */
        .upload-screen {
            position: fixed;
            inset: 0;
            background: rgba(10,0,20,0.98);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(15px);
        }
        
        .upload-screen.hidden { display: none; }
        
        .upload-box {
            border: 4px dashed var(--neon-purple);
            border-radius: 25px;
            padding: 5rem 8rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(26,15,46,0.6);
        }
        
        .upload-box:hover {
            border-color: var(--neon-cyan);
            transform: scale(1.02);
            box-shadow: 0 0 60px rgba(0,245,255,0.4);
        }
        
        .upload-icon {
            font-size: 6rem;
            margin-bottom: 1.5rem;
            filter: drop-shadow(0 0 30px var(--neon-pink));
        }
        
        .upload-title {
            font-size: 2.5rem;
            font-weight: 900;
            margin-bottom: 0.75rem;
            background: linear-gradient(135deg, var(--neon-pink), var(--neon-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--dark); }
        ::-webkit-scrollbar-thumb { background: var(--neon-purple); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--neon-pink); }
        
        /* PROJECT MODAL */
        .project-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(20px);
        }
        
        .project-modal.active { display: flex; }
        
        .project-modal-content {
            background: var(--panel);
            border: 3px solid var(--neon-cyan);
            border-radius: 20px;
            padding: 2.5rem;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 0 80px rgba(0,245,255,0.6);
        }
        
        .modal-title {
            font-size: 2rem;
            font-weight: 900;
            color: var(--neon-cyan);
            margin-bottom: 2rem;
            text-align: center;
        }
        
        .form-field {
            margin-bottom: 1.5rem;
        }
        
        .form-field label {
            display: block;
            font-size: 0.9rem;
            color: rgba(255,255,255,0.7);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .form-field input {
            width: 100%;
            padding: 0.9rem;
            background: var(--dark);
            border: 2px solid var(--border);
            color: var(--neon-cyan);
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 700;
        }
        
        .form-field input:focus {
            outline: none;
            border-color: var(--neon-cyan);
        }
        
        .modal-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
        }
        
        .project-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 1rem;
        }
        
        .project-item {
            background: var(--dark);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .project-item:hover {
            border-color: var(--neon-purple);
            transform: translateY(-2px);
        }
        
        .project-item-name {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--neon-pink);
            margin-bottom: 0.5rem;
        }
        
        .project-item-meta {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.5);
        }
        
        /* CLIP EDITOR */
        .clip-editor {
            position: fixed;
            right: 20px;
            bottom: 320px;
            width: 340px;
            background: var(--panel);
            border: 3px solid var(--neon-pink);
            border-radius: 20px;
            padding: 1.5rem;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 50px rgba(255,0,110,0.5);
        }
        
        .clip-editor.active { display: block; }
        
        .clip-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .clip-editor-title {
            font-size: 1.2rem;
            font-weight: 900;
            color: var(--neon-pink);
        }
        
        .clip-editor-close {
            background: rgba(255,0,110,0.2);
            border: none;
            color: var(--neon-pink);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            line-height: 1;
        }
        
        .clip-editor-close:hover {
            background: rgba(255,0,110,0.4);
        }
        
        .clip-property {
            margin-bottom: 1.2rem;
        }
        
        .clip-property-label {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.4rem;
        }
        
        .clip-property-value {
            background: var(--dark);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 0.6rem;
            color: var(--neon-cyan);
            font-size: 0.95rem;
            font-weight: 600;
        }
        
        .clip-property input, .clip-property select {
            width: 100%;
            background: var(--dark);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 0.6rem;
            color: var(--neon-cyan);
            font-size: 0.95rem;
            font-weight: 600;
        }
        
        .clip-property input:focus, .clip-property select:focus {
            outline: none;
            border-color: var(--neon-pink);
        }
        
        .clip-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1.5rem;
        }
        
        .clip-actions button {
            flex: 1;
            padding: 0.7rem;
            border-radius: 10px;
            border: none;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .clip-actions .apply-btn {
            background: linear-gradient(135deg, var(--neon-purple), var(--neon-pink));
            color: white;
        }
        
        .clip-actions .delete-btn {
            background: rgba(255,0,0,0.3);
            color: #ff4444;
        }
        
        .clip-actions button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255,0,110,0.4);
        }
        
        .clip-block {
            cursor: pointer;
        }
        
        .clip-block.selected {
            border: 3px solid var(--neon-pink) !important;
            box-shadow: 0 0 20px rgba(255,0,110,0.8);
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="pro-studio">
        <header>
            <div class="logo">‚ö° AUDIO1.TV PRO MAX</div>
            <div class="controls-bar">
                <button class="pro-btn" id="playBtn">‚ñ∂ PLAY</button>
                <button class="pro-btn generate" id="generateBtn">üé¨ AUTO-GENERATE</button>
                <button class="pro-btn" id="textToolBtn">‚úèÔ∏è TEXT</button>
                <button class="pro-btn" id="textOverlayBtn">üé¨ OVERLAY</button>
                <button class="pro-btn" id="saveBtn">üíæ SAVE</button>
                <button class="pro-btn" id="loadBtn">üìÇ LOAD</button>
            </div>
            <div class="stats-display">
                <div class="stat-box">
                    <div class="stat-label">Structure</div>
                    <div class="stat-value" id="structureDisplay">--</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">BPM</div>
                    <div class="stat-value" id="bpmDisplay">--</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Clips</div>
                    <div class="stat-value" id="clipsDisplay">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Quality</div>
                    <div class="stat-value" id="qualityDisplay" style="cursor:help;">--</div>
                </div>
            </div>
        </header>
        
        <aside>
            <div class="panel-header">üìÅ ASSETS & TEXT</div>
            <div style="padding:1rem;border-bottom:1px solid var(--border);">
                <button class="pro-btn" onclick="document.getElementById('assetUpload').click()" style="width:100%;margin-bottom:0.5rem;padding:0.6rem;font-size:0.8rem;">‚ûï ADD IMAGES</button>
                <button class="pro-btn" onclick="openTextTool()" style="width:100%;padding:0.6rem;font-size:0.8rem;background:linear-gradient(135deg,var(--neon-cyan),var(--neon-green));">‚úèÔ∏è CREATE TEXT</button>
                <input type="file" id="assetUpload" accept="image/*" multiple style="display:none;">
            </div>
            <div class="asset-grid" id="assetsGrid"></div>
        </aside>
        
        <main>
            <canvas id="bgCanvas"></canvas>
            <canvas id="canvas3d"></canvas>
            <canvas id="imageCanvas"></canvas>
            <canvas id="textCanvas"></canvas>
            
            <div class="structure-overlay" id="structureOverlay" style="display:none;">
                <div style="margin-bottom:0.5rem;">
                    <span class="section-badge" id="currentSection">INTRO</span>
                    <span id="sectionTime">0:00</span>
                </div>
                <div style="font-size:0.7rem;color:rgba(255,255,255,0.6);">
                    Energy: <span id="energyLevel">--</span>%
                </div>
            </div>
        </main>
        
        <aside>
            <div class="panel-header">‚öôÔ∏è PRO SETTINGS</div>
            <div class="settings-scroll">
                <div class="setting">
                    <div class="setting-title">üé¨ Mode</div>
                    <select id="modePreset">
                        <option value="custom">Custom</option>
                        <option value="cinematic">Cinematic</option>
                        <option value="musicvideo" selected>Music Video</option>
                        <option value="strobe">Strobe/EDM</option>
                        <option value="narrative">Narrative</option>
                    </select>
                </div>
                
                <div class="setting">
                    <div class="setting-title">Cut Speed</div>
                    <input type="range" class="slider" id="cutSpeed" min="0" max="100" value="70">
                    <div class="setting-val"><span id="cutSpeedVal">70</span>%</div>
                </div>
                
                <div class="setting">
                    <div class="setting-title">Strobe Intensity</div>
                    <input type="range" class="slider" id="strobeIntensity" min="0" max="100" value="50">
                    <div class="setting-val"><span id="strobeIntensityVal">50</span>%</div>
                </div>
                
                <div class="setting">
                    <div class="setting-title">3D Graphics</div>
                    <input type="range" class="slider" id="graphics3d" min="0" max="100" value="60">
                    <div class="setting-val"><span id="graphics3dVal">60</span>%</div>
                </div>
                
                <div class="setting">
                    <div class="setting-title">Text Frequency</div>
                    <input type="range" class="slider" id="textFreq" min="0" max="100" value="30">
                    <div class="setting-val"><span id="textFreqVal">30</span>%</div>
                </div>
                
                <div class="setting">
                    <div class="setting-title">Story Flow</div>
                    <input type="range" class="slider" id="storyFlow" min="0" max="100" value="70">
                    <div class="setting-val"><span id="storyFlowVal">70</span>%</div>
                </div>
                
                <div class="setting">
                    <div class="setting-title">Background Effect</div>
                    <select id="bgEffect">
                        <option value="particles">Particles</option>
                        <option value="waves">Audio Waves</option>
                        <option value="kaleidoscope">Kaleidoscope</option>
                        <option value="frequency">Frequency Bars</option>
                        <option value="none">None</option>
                    </select>
                </div>
                
                <div class="setting">
                    <div class="setting-title">‚ú® Anime.js Mode</div>
                    <label style="display:flex;align-items:center;gap:0.5rem;margin-top:0.5rem;">
                        <input type="checkbox" id="animeMode" checked style="width:20px;height:20px;">
                        <span style="font-size:0.75rem;color:rgba(255,255,255,0.7);">Use advanced animations</span>
                    </label>
                </div>
                
                <div class="setting">
                    <div class="setting-title">ü§ñ AI Director</div>
                    <select id="aiDirector">
                        <option value="smart" selected>Smart (AI Chooses)</option>
                        <option value="aggressive">Aggressive</option>
                        <option value="smooth">Smooth</option>
                        <option value="chaotic">Chaotic</option>
                        <option value="minimal">Minimal</option>
                    </select>
                </div>
            </div>
        </aside>
        
        <section class="timeline">
            <div class="timeline-bar">
                <div class="panel-header" style="padding:0;">‚è±Ô∏è TIMELINE</div>
                <div class="timeline-tools">
                    <button class="tool-btn active" id="snapBtn">SNAP: BEAT</button>
                    <button class="tool-btn" id="viewBtn">VIEW: CLIPS</button>
                    <button class="tool-btn" id="clearBtn">CLEAR</button>
                </div>
            </div>
            <div class="timeline-view">
                <div id="timelineCanvas">
                    <div class="playhead" id="playhead" style="left:0;"></div>
                </div>
            </div>
        </section>
    </div>
    
    <div class="text-tool" id="textTool">
        <h3 style="color:var(--neon-cyan);margin-bottom:1rem;">‚úèÔ∏è TEXT CREATOR</h3>
        <input type="text" class="text-input" id="textInput" placeholder="Enter text..." maxlength="50">
        <div class="text-effects">
            <button class="effect-btn active" data-effect="default">Default</button>
            <button class="effect-btn" data-effect="bounce">Bounce</button>
            <button class="effect-btn" data-effect="explode">Explode</button>
            <button class="effect-btn" data-effect="glitch">Glitch</button>
            <button class="effect-btn" data-effect="wave">Wave</button>
            <button class="effect-btn" data-effect="strobe">Strobe</button>
        </div>
        <button class="pro-btn" onclick="createTextAsset()" style="width:100%;">ADD TEXT TO LIBRARY</button>
        <button class="pro-btn" onclick="closeTextTool()" style="width:100%;margin-top:0.5rem;background:rgba(255,0,110,0.3);">CLOSE</button>
    </div>
    
    <div class="project-modal" id="textOverlayModal">
        <div class="project-modal-content" style="max-width:700px;">
            <div class="modal-title">üé¨ TEXT OVERLAY LAYER</div>
            <div class="form-field">
                <label>Text Content</label>
                <input type="text" id="overlayText" placeholder="Enter overlay text" maxlength="100">
            </div>
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem;">
                <div class="form-field">
                    <label>Position</label>
                    <select id="overlayPosition">
                        <option value="center">Center</option>
                        <option value="top">Top</option>
                        <option value="bottom">Bottom</option>
                        <option value="left">Left</option>
                        <option value="right">Right</option>
                        <option value="topLeft">Top Left</option>
                        <option value="topRight">Top Right</option>
                        <option value="bottomLeft">Bottom Left</option>
                        <option value="bottomRight">Bottom Right</option>
                    </select>
                </div>
                <div class="form-field">
                    <label>Animation Type</label>
                    <select id="overlayAnimation">
                        <option value="fadeIn">Fade In</option>
                        <option value="slideUp">Slide Up</option>
                        <option value="slideDown">Slide Down</option>
                        <option value="slideLeft">Slide Left</option>
                        <option value="slideRight">Slide Right</option>
                        <option value="bounce">Bounce</option>
                        <option value="elastic">Elastic</option>
                        <option value="spring">Spring</option>
                        <option value="glitch">Glitch</option>
                        <option value="typewriter">Typewriter</option>
                    </select>
                </div>
            </div>
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem;">
                <div class="form-field">
                    <label>Start Time (seconds)</label>
                    <input type="number" id="overlayStart" min="0" step="0.1" value="0">
                </div>
                <div class="form-field">
                    <label>Duration (seconds)</label>
                    <input type="number" id="overlayDuration" min="0.5" step="0.5" value="3">
                </div>
            </div>
            <div class="modal-buttons">
                <button class="pro-btn" onclick="addTextOverlay()" style="flex:1;">ADD OVERLAY</button>
                <button class="pro-btn" onclick="closeTextOverlay()" style="flex:1;background:rgba(255,0,110,0.3);">CANCEL</button>
            </div>
        </div>
    </div>
    
    <div class="clip-editor" id="clipEditor">
        <div class="clip-editor-header">
            <div class="clip-editor-title">‚úÇÔ∏è CLIP EDITOR</div>
            <button class="clip-editor-close" onclick="closeClipEditor()">√ó</button>
        </div>
        
        <div class="clip-property">
            <div class="clip-property-label">Asset</div>
            <select id="clipAsset" onchange="updateClipPreview()"></select>
        </div>
        
        <div class="clip-property">
            <div class="clip-property-label">Start Time (seconds)</div>
            <input type="number" id="clipStart" step="0.1" min="0">
        </div>
        
        <div class="clip-property">
            <div class="clip-property-label">Duration (seconds)</div>
            <input type="number" id="clipDuration" step="0.1" min="0.1" max="10">
        </div>
        
        <div class="clip-property">
            <div class="clip-property-label">Transition</div>
            <select id="clipTransition">
                <option value="fade">Fade</option>
                <option value="cut">Cut</option>
                <option value="dissolve">Dissolve</option>
                <option value="zoom">Zoom</option>
                <option value="slide">Slide</option>
                <option value="glitch">Glitch</option>
                <option value="strobe">Strobe</option>
                <option value="rgbsplit">RGB Split</option>
            </select>
        </div>
        
        <div class="clip-actions">
            <button class="apply-btn" onclick="applyClipChanges()">APPLY</button>
            <button class="delete-btn" onclick="deleteClip()">DELETE</button>
        </div>
    </div>
    
    <div class="project-modal" id="saveModal">
        <div class="project-modal-content">
            <div class="modal-title">üíæ SAVE PROJECT</div>
            <div class="form-field">
                <label>Project Name</label>
                <input type="text" id="projectName" placeholder="My Awesome Video" maxlength="50">
            </div>
            <div class="modal-buttons">
                <button class="pro-btn" onclick="saveProject()" style="flex:1;">SAVE</button>
                <button class="pro-btn" onclick="closeSaveModal()" style="flex:1;background:rgba(255,0,110,0.3);">CANCEL</button>
            </div>
        </div>
    </div>
    
    <div class="project-modal" id="loadModal">
        <div class="project-modal-content">
            <div class="modal-title">üìÇ LOAD PROJECT</div>
            <div class="project-list" id="projectList"></div>
            <div class="modal-buttons">
                <button class="pro-btn" onclick="closeLoadModal()" style="width:100%;">CLOSE</button>
            </div>
        </div>
    </div>
    
    <div class="upload-screen" id="uploadScreen">
        <div class="upload-box" id="uploadBox">
            <div class="upload-icon">üéµ</div>
            <div class="upload-title">DROP YOUR AUDIO</div>
            <div style="color:rgba(255,255,255,0.5);margin-top:1rem;font-size:1.1rem;">MP3, WAV, or any audio format</div>
            <input type="file" id="audioInput" accept="audio/*" style="display:none;">
        </div>
    </div>

    <script>
        console.log('‚ö° AUDIO1.TV PRO MAX - Professional Music Video Studio');
        
        // GLOBAL STATE
        const STATE = {
            audioBuffer: null,
            audioContext: null,
            analyser: null,
            source: null,
            duration: 0,
            bpm: 120,
            beats: [],
            energyCurve: [],
            structure: [],
            assets: [],
            textAssets: [],
            sequence: [],
            isPlaying: false,
            currentTime: 0,
            pixelsPerSecond: 40,
            projectName: 'Untitled Project',
            selectedClipIndex: null,
            textOverlays: [], // Manual text overlays
            animeMode: true,
            aiDirector: 'smart',
            settings: {
                mode: 'musicvideo',
                cutSpeed: 70,
                strobeIntensity: 50,
                graphics3d: 60,
                textFreq: 30,
                storyFlow: 70,
                bgEffect: 'particles',
                animeMode: true,
                aiDirector: 'smart'
            }
        };
        
        // AI ANIMATION DIRECTOR
        function getAIAnimation(clip, section, energy, bass) {
            const mode = STATE.settings.aiDirector || 'smart';
            
            const easings = {
                smooth: ['easeInOutQuad', 'easeInOutCubic', 'easeOutSine'],
                aggressive: ['spring(1, 100, 8, 0)', 'easeOutElastic(1, 0.6)', 'easeOutBounce'],
                chaotic: ['easeInOutBack(3)', 'easeOutElastic(2, 0.3)', 'easeInExpo'],
                minimal: ['linear', 'easeInOutQuad']
            };
            
            if (mode === 'smart') {
                // AI analyzes context
                if (section.type === 'chorus' && energy > 0.7) {
                    return {
                        easing: bass > 0.6 ? 'spring(1, 120, 10, 0)' : 'easeOutElastic(1, 0.7)',
                        duration: 300 + Math.random() * 200,
                        scale: [1, 1.2 + bass * 0.3],
                        rotate: bass > 0.5 ? '0.25turn' : '0.1turn'
                    };
                } else if (section.type === 'verse' && energy < 0.4) {
                    return {
                        easing: 'easeOutQuad',
                        duration: 2000,
                        scale: [1, 1.05],
                        rotate: '0.05turn'
                    };
                } else if (section.type === 'intro') {
                    return {
                        easing: 'easeInOutSine',
                        duration: 3000,
                        scale: [0.95, 1],
                        rotate: '0'
                    };
                } else if (section.type === 'bridge') {
                    return {
                        easing: 'easeInOutCubic',
                        duration: 1500,
                        scale: [1, 1.15],
                        rotate: '0.15turn'
                    };
                }
                
                // Default smart behavior
                return {
                    easing: energy > 0.6 ? 'easeOutExpo' : 'easeInOutQuad',
                    duration: 1000,
                    scale: [1, 1.1],
                    rotate: '0.1turn'
                };
            }
            
            // Preset modes
            const modeEasings = easings[mode] || easings.smooth;
            const easing = modeEasings[Math.floor(Math.random() * modeEasings.length)];
            
            const durations = {
                smooth: [2000, 3000],
                aggressive: [300, 800],
                chaotic: [200, 1500],
                minimal: [1500, 2500]
            };
            
            const [minDur, maxDur] = durations[mode] || [1000, 2000];
            
            return {
                easing: easing,
                duration: minDur + Math.random() * (maxDur - minDur),
                scale: mode === 'aggressive' ? [1, 1.3] : [1, 1.1],
                rotate: mode === 'chaotic' ? `${Math.random() * 0.5}turn` : '0.1turn'
            };
        };
        
        // CANVAS SETUP
        const bgCanvas = document.getElementById('bgCanvas');
        const canvas3d = document.getElementById('canvas3d');
        const imageCanvas = document.getElementById('imageCanvas');
        const textCanvas = document.getElementById('textCanvas');
        
        const bgCtx = bgCanvas.getContext('2d');
        const imageCtx = imageCanvas.getContext('2d');
        const textCtx = textCanvas.getContext('2d');
        
        // THREE.JS SETUP
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, canvas3d.clientWidth/canvas3d.clientHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({canvas: canvas3d, alpha: true});
        renderer.setClearColor(0x000000, 0);
        camera.position.z = 5;
        
        const textMesh3d = new THREE.Group();
        scene.add(textMesh3d);
        
        const particles = [];
        for (let i = 0; i < 500; i++) {
            const geometry = new THREE.SphereGeometry(0.05, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff });
            const particle = new THREE.Mesh(geometry, material);
            particle.position.set(
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 10
            );
            particles.push(particle);
            scene.add(particle);
        }
        
        function resizeCanvases() {
            [bgCanvas, canvas3d, imageCanvas, textCanvas].forEach(c => {
                c.width = c.clientWidth;
                c.height = c.clientHeight;
            });
            camera.aspect = canvas3d.clientWidth / canvas3d.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas3d.clientWidth, canvas3d.clientHeight);
        }
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);
        
        // AUDIO UPLOAD
        document.getElementById('uploadBox').onclick = () => document.getElementById('audioInput').click();
        document.getElementById('audioInput').onchange = (e) => {
            if (e.target.files[0]) {
                const reader = new FileReader();
                reader.onload = (e) => processAudio(e.target.result);
                reader.readAsArrayBuffer(e.target.files[0]);
            }
        };
        
        // ADVANCED AUDIO PROCESSING
        async function processAudio(arrayBuffer) {
            STATE.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            STATE.analyser = STATE.audioContext.createAnalyser();
            STATE.analyser.fftSize = 4096;
            
            const buffer = await STATE.audioContext.decodeAudioData(arrayBuffer);
            STATE.audioBuffer = buffer;
            STATE.duration = buffer.duration;
            
            document.getElementById('uploadScreen').classList.add('hidden');
            
            // BEAT DETECTION
            detectBeats(buffer);
            
            // ENERGY CURVE ANALYSIS
            analyzeEnergyCurve(buffer);
            
            // SONG STRUCTURE DETECTION
            detectStructure();
            
            // UPDATE UI
            document.getElementById('bpmDisplay').textContent = STATE.bpm;
            document.getElementById('structureDisplay').textContent = STATE.structure.length;
            
            renderTimeline();
            
            console.log('‚úÖ Loaded:', STATE.duration.toFixed(1)+'s', STATE.beats.length, 'beats @', STATE.bpm, 'BPM');
            console.log('üìä Structure:', STATE.structure);
        }
        
        function detectBeats(buffer) {
            const data = buffer.getChannelData(0);
            const sr = buffer.sampleRate;
            const win = Math.floor(sr * 0.043); // ~43ms optimal for beat detection
            
            const energy = [];
            for (let i = 0; i < data.length; i += win) {
                let sum = 0;
                for (let j = 0; j < win && i+j < data.length; j++) {
                    sum += Math.pow(data[i+j], 2);
                }
                energy.push(sum / win);
            }
            
            const beats = [];
            for (let i = 5; i < energy.length - 5; i++) {
                const localAvg = energy.slice(i-5, i).concat(energy.slice(i+1, i+6)).reduce((a,b) => a+b) / 10;
                if (energy[i] > localAvg * 1.5 && energy[i] > 0.001) {
                    const time = (i * win) / sr;
                    if (beats.length === 0 || time - beats[beats.length-1] > 0.15) {
                        beats.push(time);
                    }
                }
            }
            
            STATE.beats = beats;
            
            if (beats.length > 10) {
                const intervals = [];
                for (let i = 1; i < Math.min(40, beats.length); i++) {
                    intervals.push(beats[i] - beats[i-1]);
                }
                const avgInterval = intervals.reduce((a,b) => a+b) / intervals.length;
                STATE.bpm = Math.round(60 / avgInterval);
            }
        }
        
        function analyzeEnergyCurve(buffer) {
            const data = buffer.getChannelData(0);
            const sr = buffer.sampleRate;
            const chunkSize = Math.floor(sr * 0.5); // 0.5s chunks
            
            STATE.energyCurve = [];
            for (let i = 0; i < data.length; i += chunkSize) {
                let sum = 0;
                for (let j = 0; j < chunkSize && i+j < data.length; j++) {
                    sum += Math.abs(data[i+j]);
                }
                const energy = sum / chunkSize;
                STATE.energyCurve.push({
                    time: i / sr,
                    energy: energy,
                    normalized: 0
                });
            }
            
            // Normalize
            const maxEnergy = Math.max(...STATE.energyCurve.map(e => e.energy));
            STATE.energyCurve.forEach(e => e.normalized = e.energy / maxEnergy);
        }
        
        function detectStructure() {
            const duration = STATE.duration;
            STATE.structure = [];
            
            // Heuristic structure detection based on energy & position
            const sections = [];
            
            // Intro (usually 0-10% of song, lower energy)
            const introEnd = Math.min(duration * 0.1, 15);
            sections.push({ type: 'intro', start: 0, end: introEnd, energy: 'low' });
            
            // Verse/Chorus pattern detection
            const mainSection = duration - introEnd - (duration * 0.05);
            const segmentCount = Math.floor(mainSection / 20); // ~20s segments
            
            let currentTime = introEnd;
            for (let i = 0; i < segmentCount; i++) {
                const segmentDuration = 20;
                const energy = getAverageEnergy(currentTime, currentTime + segmentDuration);
                
                // High energy = Chorus, Low = Verse
                const type = energy > 0.6 ? 'chorus' : 'verse';
                sections.push({ 
                    type: type, 
                    start: currentTime, 
                    end: currentTime + segmentDuration,
                    energy: energy > 0.7 ? 'high' : energy > 0.4 ? 'medium' : 'low'
                });
                
                currentTime += segmentDuration;
            }
            
            // Bridge (often 70-80% through song)
            if (duration > 90) {
                const bridgeStart = duration * 0.7;
                sections.push({ type: 'bridge', start: bridgeStart, end: bridgeStart + 15, energy: 'medium' });
            }
            
            // Outro (last 5% or 10s)
            const outroStart = Math.max(duration - 10, duration * 0.95);
            sections.push({ type: 'outro', start: outroStart, end: duration, energy: 'low' });
            
            STATE.structure = sections;
        }
        
        function getAverageEnergy(startTime, endTime) {
            const relevantPoints = STATE.energyCurve.filter(e => e.time >= startTime && e.time <= endTime);
            if (relevantPoints.length === 0) return 0.5;
            return relevantPoints.reduce((sum, e) => sum + e.normalized, 0) / relevantPoints.length;
        }
        
        function getSectionAt(time) {
            return STATE.structure.find(s => time >= s.start && time < s.end) || { type: 'unknown', energy: 'medium' };
        }
        
        // ASSET MANAGEMENT
        document.getElementById('assetUpload').onchange = (e) => {
            let loaded = 0;
            const totalFiles = e.target.files.length;
            
            Array.from(e.target.files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        STATE.assets.push({
                            id: Date.now() + Math.random(),
                            type: 'image',
                            name: file.name,
                            img: img,
                            dataUrl: e.target.result
                        });
                        renderAssets();
                        
                        loaded++;
                        // Auto-generate when all images loaded
                        if (loaded === totalFiles && STATE.audioBuffer) {
                            console.log('üé¨ Auto-generating with', STATE.assets.length, 'total images');
                            setTimeout(() => generateProSequence(), 500);
                        }
                    };
                };
                reader.readAsDataURL(file);
            });
        };
        
        function renderAssets() {
            const grid = document.getElementById('assetsGrid');
            grid.innerHTML = '';
            
            const allAssets = [...STATE.assets, ...STATE.textAssets];
            
            allAssets.forEach((asset, globalIndex) => {
                const div = document.createElement('div');
                div.className = 'asset' + (asset.type === 'text' ? ' text-asset' : '');
                div.draggable = true;
                div.dataset.assetId = asset.id;
                
                if (asset.type === 'image') {
                    div.innerHTML = `<img src="${asset.dataUrl}"><div class="asset-badge">IMG</div>`;
                } else {
                    div.innerHTML = `${asset.text}<div class="asset-badge text">TXT</div>`;
                }
                
                // Drag start
                div.ondragstart = (e) => {
                    e.dataTransfer.setData('assetId', asset.id);
                    e.dataTransfer.effectAllowed = 'copy';
                };
                
                grid.appendChild(div);
            });
        }
        
        // TEXT TOOL
        function openTextTool() {
            document.getElementById('textTool').classList.add('active');
        }
        window.openTextTool = openTextTool;
        
        function closeTextTool() {
            document.getElementById('textTool').classList.remove('active');
        }
        window.closeTextTool = closeTextTool;
        
        document.querySelectorAll('.effect-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.effect-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            };
        });
        
        function createTextAsset() {
            const text = document.getElementById('textInput').value.trim();
            if (!text) return alert('Enter some text!');
            
            const effect = document.querySelector('.effect-btn.active').dataset.effect;
            
            // Parse hashtags from text
            const hashtagRegex = /#\w+/g;
            const hashtags = text.match(hashtagRegex) || [];
            
            // Add main text asset
            STATE.textAssets.push({
                id: Date.now() + Math.random(),
                type: 'text',
                text: text,
                effect: effect
            });
            
            // Add each hashtag as separate text asset
            hashtags.forEach((tag, i) => {
                STATE.textAssets.push({
                    id: Date.now() + Math.random() + (i + 1) * 0.001,
                    type: 'text',
                    text: tag,
                    effect: 'bounce' // Hashtags get bounce effect
                });
            });
            
            renderAssets();
            document.getElementById('textInput').value = '';
            closeTextTool();
            
            if (hashtags.length > 0) {
                console.log('üíô Parsed', hashtags.length, 'hashtags:', hashtags.join(' '));
            }
            
            // Auto-generate if audio is loaded
            if (STATE.audioBuffer) {
                console.log('üé¨ Auto-generating with new text assets');
                setTimeout(() => generateProSequence(), 300);
            }
        }
        window.createTextAsset = createTextAsset;
        
        // ADVANCED SEQUENCE GENERATION
        document.getElementById('generateBtn').onclick = () => {
            if (!STATE.audioBuffer) return alert('Load audio first!');
            
            generateProSequence();
        };
        
        // TEXT OVERLAY SYSTEM
        document.getElementById('textOverlayBtn').onclick = () => {
            document.getElementById('textOverlayModal').classList.add('active');
        };
        
        function closeTextOverlay() {
            document.getElementById('textOverlayModal').classList.remove('active');
        }
        window.closeTextOverlay = closeTextOverlay;
        
        function addTextOverlay() {
            const text = document.getElementById('overlayText').value.trim();
            if (!text) return alert('Enter text for overlay!');
            
            const overlay = {
                id: Date.now(),
                text: text,
                position: document.getElementById('overlayPosition').value,
                animation: document.getElementById('overlayAnimation').value,
                start: parseFloat(document.getElementById('overlayStart').value),
                duration: parseFloat(document.getElementById('overlayDuration').value)
            };
            
            STATE.textOverlays.push(overlay);
            closeTextOverlay();
            
            console.log('‚ú® Text overlay added at', overlay.start.toFixed(1) + 's:', overlay.text);
            alert('‚úÖ Overlay added! Play video to see it.');
            
            // Clear form
            document.getElementById('overlayText').value = '';
        }
        window.addTextOverlay = addTextOverlay;
        
        // SETTINGS HANDLERS
        document.getElementById('animeMode').onchange = (e) => {
            STATE.settings.animeMode = e.target.checked;
            console.log('‚ú® Anime.js mode:', STATE.settings.animeMode ? 'ON' : 'OFF');
        };
        
        document.getElementById('aiDirector').onchange = (e) => {
            STATE.settings.aiDirector = e.target.value;
            console.log('ü§ñ AI Director mode:', e.target.value);
            
            // Regenerate if sequence exists
            if (STATE.audioBuffer && (STATE.assets.length > 0 || STATE.textAssets.length > 0)) {
                console.log('‚ö° Regenerating with new AI Director mode');
                generateProSequence();
            }
        };
        
        function generateProSequence() {
            STATE.sequence = [];
            
            const cutSpeed = STATE.settings.cutSpeed / 100;
            const strobeIntensity = STATE.settings.strobeIntensity / 100;
            const textFreq = STATE.settings.textFreq / 100;
            
            STATE.structure.forEach(section => {
                const sectionBeats = STATE.beats.filter(b => b >= section.start && b < section.end);
                
                // Determine clip strategy based on section
                let clipInterval, baseDuration;
                
                switch(section.type) {
                    case 'intro':
                        clipInterval = 8; // Every 8 beats (slow)
                        baseDuration = 3;
                        break;
                    case 'verse':
                        clipInterval = 4; // Every 4 beats
                        baseDuration = 2;
                        break;
                    case 'chorus':
                        // STROBE MODE on chorus!
                        if (strobeIntensity > 0.5) {
                            clipInterval = 1; // Every beat
                            baseDuration = 0.2 + (1 - strobeIntensity) * 0.3; // 0.2-0.5s
                        } else {
                            clipInterval = 2;
                            baseDuration = 1;
                        }
                        break;
                    case 'bridge':
                        clipInterval = 2;
                        baseDuration = 2.5;
                        break;
                    case 'outro':
                        clipInterval = 8;
                        baseDuration = 4;
                        break;
                    default:
                        clipInterval = 4;
                        baseDuration = 2;
                }
                
                // Adjust by cut speed
                clipInterval = Math.max(1, Math.round(clipInterval * (1 - cutSpeed * 0.5)));
                
                // Generate clips for this section
                sectionBeats.filter((_, i) => i % clipInterval === 0).forEach((beat, idx) => {
                    // Decide asset type
                    const useText = Math.random() < textFreq && STATE.textAssets.length > 0;
                    let asset;
                    
                    if (useText) {
                        asset = STATE.textAssets[Math.floor(Math.random() * STATE.textAssets.length)];
                    } else if (STATE.assets.length > 0) {
                        asset = STATE.assets[Math.floor(Math.random() * STATE.assets.length)];
                    } else {
                        return; // Skip if no assets
                    }
                    
                    // Choose transition
                    const isStrongBeat = idx % 4 === 0;
                    let transition = 'fade';
                    
                    if (section.type === 'chorus' && strobeIntensity > 0.5) {
                        transition = Math.random() < 0.5 ? 'strobe' : 'cut';
                    } else if (section.energy === 'high') {
                        const transitions = ['cut', 'zoom', 'glitch', 'rgbsplit'];
                        transition = transitions[Math.floor(Math.random() * transitions.length)];
                    } else if (isStrongBeat) {
                        transition = 'zoom';
                    }
                    
                    STATE.sequence.push({
                        asset: asset,
                        start: beat,
                        duration: baseDuration * (0.8 + Math.random() * 0.4),
                        transition: transition,
                        section: section.type
                    });
                });
            });
            
            document.getElementById('clipsDisplay').textContent = STATE.sequence.length;
            renderTimeline();
            
            console.log('‚úÖ Generated', STATE.sequence.length, 'clips with advanced structure');
        }
        
        // TIMELINE DRAG & DROP
        const timelineView = document.querySelector('.timeline-view');
        
        timelineView.ondragover = (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        };
        
        timelineView.ondrop = (e) => {
            e.preventDefault();
            
            const assetId = e.dataTransfer.getData('assetId');
            if (!assetId) return;
            
            // Find asset by ID
            const allAssets = [...STATE.assets, ...STATE.textAssets];
            const asset = allAssets.find(a => a.id == assetId);
            if (!asset) return;
            
            // Calculate drop time from mouse position
            const rect = timelineView.getBoundingClientRect();
            const scrollLeft = timelineView.scrollLeft;
            const dropX = e.clientX - rect.left + scrollLeft;
            const dropTime = Math.max(0, dropX / STATE.pixelsPerSecond);
            
            // Snap to nearest beat
            let startTime = dropTime;
            if (STATE.beats.length > 0) {
                const nearestBeat = STATE.beats.reduce((prev, curr) => 
                    Math.abs(curr - dropTime) < Math.abs(prev - dropTime) ? curr : prev
                );
                if (Math.abs(nearestBeat - dropTime) < 0.5) {
                    startTime = nearestBeat;
                }
            }
            
            // Add clip to timeline
            STATE.sequence.push({
                asset: asset,
                start: startTime,
                duration: 2.0,
                transition: 'fade',
                section: getSectionAt(startTime).type
            });
            
            // Sort by start time
            STATE.sequence.sort((a, b) => a.start - b.start);
            
            document.getElementById('clipsDisplay').textContent = STATE.sequence.length;
            renderTimeline();
            
            console.log('‚ûï Dropped', asset.type, 'at', startTime.toFixed(2) + 's');
        };
        
        // TIMELINE RENDERING
        function renderTimeline() {
            const timeline = document.getElementById('timelineCanvas');
            timeline.innerHTML = '<div class="playhead" id="playhead" style="left:0;"></div>';
            
            const width = STATE.duration * STATE.pixelsPerSecond;
            timeline.style.width = width + 'px';
            
            // Show hint if no clips
            if (STATE.sequence.length === 0 && STATE.audioBuffer) {
                const hint = document.createElement('div');
                hint.className = 'timeline-drop-hint';
                hint.textContent = '‚ú® Drag assets here or click AUTO-GENERATE';
                timeline.appendChild(hint);
            }
            
            // Draw structure markers
            STATE.structure.forEach(section => {
                const marker = document.createElement('div');
                marker.className = `structure-marker ${section.type}`;
                marker.style.left = (section.start * STATE.pixelsPerSecond) + 'px';
                marker.style.width = ((section.end - section.start) * STATE.pixelsPerSecond) + 'px';
                
                const label = document.createElement('div');
                label.className = 'structure-label';
                label.textContent = section.type.toUpperCase();
                label.style.color = getComputedStyle(marker).borderLeftColor;
                marker.appendChild(label);
                
                timeline.appendChild(marker);
            });
            
            // Draw clips
            STATE.sequence.forEach((clip, index) => {
                const block = document.createElement('div');
                block.className = 'clip-block' + 
                    (clip.transition === 'strobe' ? ' strobe' : '') +
                    (clip.asset.type === 'text' ? ' text-clip' : '') +
                    (STATE.selectedClipIndex === index ? ' selected' : '');
                block.style.left = (clip.start * STATE.pixelsPerSecond) + 'px';
                block.style.width = (clip.duration * STATE.pixelsPerSecond) + 'px';
                block.textContent = clip.asset.type === 'text' ? clip.asset.text.slice(0, 8) : '‚óè';
                block.dataset.clipIndex = index;
                block.onclick = () => selectClip(index);
                timeline.appendChild(block);
            });
        }
        
        // PLAYBACK
        document.getElementById('playBtn').onclick = () => {
            if (!STATE.audioBuffer) return;
            
            if (STATE.isPlaying) {
                stopPlayback();
            } else {
                startPlayback();
            }
        };
        
        function startPlayback() {
            STATE.source = STATE.audioContext.createBufferSource();
            STATE.source.buffer = STATE.audioBuffer;
            STATE.source.connect(STATE.analyser);
            STATE.analyser.connect(STATE.audioContext.destination);
            STATE.source.start(0);
            
            STATE.isPlaying = true;
            STATE.startTime = STATE.audioContext.currentTime;
            document.getElementById('playBtn').textContent = '‚è∏ PAUSE';
            document.getElementById('structureOverlay').style.display = 'block';
            
            STATE.source.onended = stopPlayback;
            animatePlayback();
        }
        
        function stopPlayback() {
            if (STATE.source) STATE.source.stop();
            STATE.isPlaying = false;
            document.getElementById('playBtn').textContent = '‚ñ∂ PLAY';
            document.getElementById('structureOverlay').style.display = 'none';
        }
        
        function animatePlayback() {
            if (!STATE.isPlaying) return;
            
            STATE.currentTime = STATE.audioContext.currentTime - STATE.startTime;
            document.getElementById('playhead').style.left = (STATE.currentTime * STATE.pixelsPerSecond) + 'px';
            
            // Update structure overlay
            const section = getSectionAt(STATE.currentTime);
            document.getElementById('currentSection').textContent = section.type.toUpperCase();
            document.getElementById('sectionTime').textContent = formatTime(STATE.currentTime);
            
            const energyPoint = STATE.energyCurve.find(e => Math.abs(e.time - STATE.currentTime) < 0.5);
            if (energyPoint) {
                document.getElementById('energyLevel').textContent = Math.round(energyPoint.normalized * 100);
            }
            
            // Get audio data
            const audioData = new Uint8Array(STATE.analyser.frequencyBinCount);
            STATE.analyser.getByteFrequencyData(audioData);
            const bass = audioData.slice(0, 10).reduce((a,b) => a+b, 0) / 10 / 255;
            
            // Render background
            renderBackground(bass);
            
            // Render 3D
            render3D(bass);
            
            // Render current clip
            const activeClip = STATE.sequence.find(c => 
                STATE.currentTime >= c.start && STATE.currentTime < c.start + c.duration
            );
            
            if (activeClip) {
                if (activeClip.asset.type === 'image') {
                    renderImage(activeClip.asset.img, activeClip.transition, bass);
                } else if (activeClip.asset.type === 'text') {
                    renderText(activeClip.asset.text, activeClip.asset.effect, bass);
                }
            } else {
                imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
            }
            
            requestAnimationFrame(animatePlayback);
        }
        
        function renderBackground(bass) {
            if (STATE.settings.bgEffect === 'none') {
                bgCtx.fillStyle = '#000';
                bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
                return;
            }
            
            if (STATE.settings.bgEffect === 'particles') {
                bgCtx.fillStyle = 'rgba(10, 0, 20, 0.1)';
                bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
                
                for (let i = 0; i < 50; i++) {
                    const x = (Math.sin(Date.now() * 0.001 + i) * 0.5 + 0.5) * bgCanvas.width;
                    const y = (Math.cos(Date.now() * 0.0015 + i) * 0.5 + 0.5) * bgCanvas.height;
                    const size = 3 + bass * 10;
                    
                    bgCtx.fillStyle = `hsla(${(i * 10 + Date.now() * 0.1) % 360}, 80%, 60%, 0.6)`;
                    bgCtx.beginPath();
                    bgCtx.arc(x, y, size, 0, Math.PI * 2);
                    bgCtx.fill();
                }
            }
        }
        
        function render3D(bass) {
            if (STATE.settings.graphics3d === 0) return;
            
            // Animate particles
            particles.forEach((p, i) => {
                p.position.y += 0.01;
                if (p.position.y > 5) p.position.y = -5;
                p.rotation.x += 0.01;
                p.rotation.y += 0.01;
                
                // Bass reaction
                p.scale.setScalar(1 + bass * 0.5);
            });
            
            renderer.render(scene, camera);
        }
        
        function renderImage(img, transition, bass) {
            imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
            
            const scale = Math.min(imageCanvas.width / img.width, imageCanvas.height / img.height);
            const x = (imageCanvas.width - img.width * scale) / 2;
            const y = (imageCanvas.height - img.height * scale) / 2;
            
            imageCtx.save();
            
            // Apply transition effects
            if (transition === 'strobe') {
                imageCtx.globalAlpha = Math.random() < 0.5 ? 1 : 0.3;
            } else if (transition === 'glitch') {
                imageCtx.translate(Math.random() * 10 - 5, Math.random() * 10 - 5);
            } else if (transition === 'zoom') {
                const zoomScale = 1 + bass * 0.2;
                imageCtx.scale(zoomScale, zoomScale);
                imageCtx.translate(-x * (zoomScale - 1), -y * (zoomScale - 1));
            }
            
            imageCtx.drawImage(img, x, y, img.width * scale, img.height * scale);
            imageCtx.restore();
        }
        
        function renderText(text, effect, bass) {
            textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
            
            const fontSize = 80 + bass * 40;
            textCtx.font = `900 ${fontSize}px Arial`;
            textCtx.textAlign = 'center';
            textCtx.textBaseline = 'middle';
            
            const x = textCanvas.width / 2;
            const y = textCanvas.height / 2;
            
            textCtx.save();
            
            // Apply effects
            if (effect === 'bounce') {
                textCtx.translate(0, Math.sin(Date.now() * 0.005) * 30);
            } else if (effect === 'explode') {
                const scale = 1 + Math.sin(Date.now() * 0.01) * 0.3;
                textCtx.scale(scale, scale);
            } else if (effect === 'glitch') {
                textCtx.fillStyle = `rgba(255,0,110,${Math.random()})`;
                textCtx.fillText(text, x + Math.random() * 10 - 5, y);
                textCtx.fillStyle = `rgba(0,245,255,${Math.random()})`;
                textCtx.fillText(text, x + Math.random() * 10 - 5, y);
            } else if (effect === 'strobe') {
                textCtx.globalAlpha = Math.random() < 0.7 ? 1 : 0;
            }
            
            // Gradient fill
            const gradient = textCtx.createLinearGradient(x - 200, y, x + 200, y);
            gradient.addColorStop(0, '#ff006e');
            gradient.addColorStop(0.5, '#00f5ff');
            gradient.addColorStop(1, '#00ff88');
            textCtx.fillStyle = gradient;
            
            textCtx.strokeStyle = '#000';
            textCtx.lineWidth = 4;
            textCtx.strokeText(text, x, y);
            textCtx.fillText(text, x, y);
            
            textCtx.restore();
        }
        
        // SETTINGS - WIRE UP WITH AUTO-REGENERATE
        ['cutSpeed', 'strobeIntensity', 'graphics3d', 'textFreq', 'storyFlow'].forEach(id => {
            document.getElementById(id).oninput = (e) => {
                STATE.settings[id] = parseInt(e.target.value);
                document.getElementById(id + 'Val').textContent = e.target.value;
            };
            
            // Auto-regenerate on mouse up (after dragging slider)
            document.getElementById(id).onmouseup = () => {
                if (STATE.audioBuffer && (STATE.assets.length > 0 || STATE.textAssets.length > 0)) {
                    console.log('‚ö° Regenerating with new', id, '=', STATE.settings[id]);
                    generateProSequence();
                }
            };
        });
        
        document.getElementById('bgEffect').onchange = (e) => {
            STATE.settings.bgEffect = e.target.value;
        };
        
        document.getElementById('modePreset').onchange = (e) => {
            const presets = {
                cinematic: { cutSpeed: 20, strobeIntensity: 0, graphics3d: 30, textFreq: 20, storyFlow: 90 },
                musicvideo: { cutSpeed: 70, strobeIntensity: 50, graphics3d: 60, textFreq: 30, storyFlow: 70 },
                strobe: { cutSpeed: 95, strobeIntensity: 90, graphics3d: 80, textFreq: 50, storyFlow: 30 },
                narrative: { cutSpeed: 40, strobeIntensity: 10, graphics3d: 40, textFreq: 60, storyFlow: 95 }
            };
            
            const preset = presets[e.target.value];
            if (preset) {
                Object.keys(preset).forEach(key => {
                    STATE.settings[key] = preset[key];
                    const slider = document.getElementById(key);
                    const display = document.getElementById(key + 'Val');
                    if (slider) {
                        slider.value = preset[key];
                        if (display) display.textContent = preset[key];
                    }
                });
                
                // Auto-regenerate when preset changes
                if (STATE.audioBuffer && (STATE.assets.length > 0 || STATE.textAssets.length > 0)) {
                    console.log('‚ö° Applying preset:', e.target.value);
                    setTimeout(() => generateProSequence(), 100);
                }
            }
        };
        
        // PROJECT PERSISTENCE
        document.getElementById('saveBtn').onclick = () => {
            document.getElementById('saveModal').classList.add('active');
            document.getElementById('projectName').value = STATE.projectName || '';
        };
        
        document.getElementById('loadBtn').onclick = () => {
            renderProjectList();
            document.getElementById('loadModal').classList.add('active');
        };
        
        function closeSaveModal() {
            document.getElementById('saveModal').classList.remove('active');
        }
        window.closeSaveModal = closeSaveModal;
        
        function closeLoadModal() {
            document.getElementById('loadModal').classList.remove('active');
        }
        window.closeLoadModal = closeLoadModal;
        
        function saveProject() {
            const name = document.getElementById('projectName').value.trim() || 'Untitled Project';
            
            const project = {
                id: Date.now(),
                name: name,
                created: new Date().toISOString(),
                duration: STATE.duration,
                bpm: STATE.bpm,
                beats: STATE.beats,
                energyCurve: STATE.energyCurve,
                structure: STATE.structure,
                assets: STATE.assets,
                textAssets: STATE.textAssets,
                sequence: STATE.sequence.map(s => ({
                    assetId: s.asset.id,
                    assetType: s.asset.type,
                    start: s.start,
                    duration: s.duration,
                    transition: s.transition,
                    section: s.section
                })),
                settings: STATE.settings
            };
            
            const projects = JSON.parse(localStorage.getItem('audio1tv_promax_projects') || '[]');
            projects.push(project);
            localStorage.setItem('audio1tv_promax_projects', JSON.stringify(projects));
            
            STATE.projectName = name;
            alert('‚úÖ Project "' + name + '" saved!');
            closeSaveModal();
            
            console.log('üíæ Saved project:', project);
        }
        window.saveProject = saveProject;
        
        function renderProjectList() {
            const projects = JSON.parse(localStorage.getItem('audio1tv_promax_projects') || '[]');
            const list = document.getElementById('projectList');
            
            if (projects.length === 0) {
                list.innerHTML = '<div style="text-align:center;color:rgba(255,255,255,0.4);padding:3rem;">No saved projects yet</div>';
                return;
            }
            
            list.innerHTML = projects.reverse().map(p => `
                <div class="project-item" onclick="loadProject(${p.id})">
                    <div class="project-item-name">${p.name}</div>
                    <div class="project-item-meta">
                        ${new Date(p.created).toLocaleDateString()} ‚Ä¢ 
                        ${p.bpm || '--'} BPM ‚Ä¢ 
                        ${p.sequence?.length || 0} clips
                    </div>
                </div>
            `).join('');
        }
        window.renderProjectList = renderProjectList;
        
        function loadProject(projectId) {
            const projects = JSON.parse(localStorage.getItem('audio1tv_promax_projects') || '[]');
            const project = projects.find(p => p.id === projectId);
            
            if (!project) {
                alert('‚ö†Ô∏è Project not found');
                return;
            }
            
            // Restore state
            STATE.projectName = project.name;
            STATE.duration = project.duration;
            STATE.bpm = project.bpm;
            STATE.beats = project.beats;
            STATE.energyCurve = project.energyCurve || [];
            STATE.structure = project.structure || [];
            STATE.assets = project.assets || [];
            STATE.textAssets = project.textAssets || [];
            STATE.settings = project.settings || STATE.settings;
            
            // Restore sequence
            STATE.sequence = project.sequence.map(s => {
                const allAssets = [...STATE.assets, ...STATE.textAssets];
                const asset = allAssets.find(a => a.id === s.assetId);
                return {
                    asset: asset || allAssets[0],
                    start: s.start,
                    duration: s.duration,
                    transition: s.transition,
                    section: s.section
                };
            });
            
            // Update UI
            document.getElementById('bpmDisplay').textContent = STATE.bpm;
            document.getElementById('structureDisplay').textContent = STATE.structure.length;
            document.getElementById('clipsDisplay').textContent = STATE.sequence.length;
            
            // Update sliders
            Object.keys(STATE.settings).forEach(key => {
                const slider = document.getElementById(key);
                const display = document.getElementById(key + 'Val');
                if (slider && typeof STATE.settings[key] === 'number') {
                    slider.value = STATE.settings[key];
                    if (display) display.textContent = STATE.settings[key];
                }
            });
            
            renderAssets();
            renderTimeline();
            closeLoadModal();
            
            alert('‚úÖ Loaded: ' + project.name);
            console.log('üìÇ Loaded project:', project);
        }
        window.loadProject = loadProject;
        
        // CLIP EDITOR
        function selectClip(index) {
            STATE.selectedClipIndex = index;
            const clip = STATE.sequence[index];
            
            // Populate editor
            const assetSelect = document.getElementById('clipAsset');
            assetSelect.innerHTML = '';
            
            const allAssets = [...STATE.assets, ...STATE.textAssets];
            allAssets.forEach((asset, i) => {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = asset.type === 'image' ? asset.name : asset.text;
                if (asset.id === clip.asset.id) option.selected = true;
                assetSelect.appendChild(option);
            });
            
            document.getElementById('clipStart').value = clip.start.toFixed(2);
            document.getElementById('clipDuration').value = clip.duration.toFixed(2);
            document.getElementById('clipTransition').value = clip.transition;
            
            // Show editor
            document.getElementById('clipEditor').classList.add('active');
            
            // Update timeline
            renderTimeline();
            
            console.log('‚úÇÔ∏è Selected clip', index, clip);
        }
        window.selectClip = selectClip;
        
        function closeClipEditor() {
            STATE.selectedClipIndex = null;
            document.getElementById('clipEditor').classList.remove('active');
            renderTimeline();
        }
        window.closeClipEditor = closeClipEditor;
        
        function applyClipChanges() {
            if (STATE.selectedClipIndex === null) return;
            
            const clip = STATE.sequence[STATE.selectedClipIndex];
            const allAssets = [...STATE.assets, ...STATE.textAssets];
            
            // Update clip properties
            const assetIndex = parseInt(document.getElementById('clipAsset').value);
            clip.asset = allAssets[assetIndex];
            clip.start = parseFloat(document.getElementById('clipStart').value);
            clip.duration = parseFloat(document.getElementById('clipDuration').value);
            clip.transition = document.getElementById('clipTransition').value;
            
            // Re-sort sequence by start time
            STATE.sequence.sort((a, b) => a.start - b.start);
            
            renderTimeline();
            console.log('‚úÖ Updated clip:', clip);
        }
        window.applyClipChanges = applyClipChanges;
        
        function deleteClip() {
            if (STATE.selectedClipIndex === null) return;
            
            if (confirm('Delete this clip?')) {
                STATE.sequence.splice(STATE.selectedClipIndex, 1);
                document.getElementById('clipsDisplay').textContent = STATE.sequence.length;
                closeClipEditor();
                console.log('üóëÔ∏è Deleted clip at index', STATE.selectedClipIndex);
            }
        }
        window.deleteClip = deleteClip;
        
        function updateClipPreview() {
            // Could add live preview here in the future
        }
        window.updateClipPreview = updateClipPreview;
        
        // UTILITIES
        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }
        
        // INIT
        renderAssets();
        
        // Background animation even without audio
        function backgroundLoop() {
            if (!STATE.isPlaying) {
                bgCtx.fillStyle = 'rgba(10, 0, 20, 0.05)';
                bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
            }
            requestAnimationFrame(backgroundLoop);
        }
        backgroundLoop();
        
        console.log('üé¨ Studio ready! Drop your audio to begin.');
    </script>
</body>
</html>
