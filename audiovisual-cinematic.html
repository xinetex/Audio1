<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audiovisual Cinema</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
        }
        #upload-area {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 2px dashed rgba(102, 126, 234, 0.4);
            border-radius: 20px;
            padding: 3rem 4rem;
            text-align: center;
            pointer-events: all;
            cursor: pointer;
            transition: all 0.3s;
        }
        #upload-area:hover { border-color: #667eea; background: rgba(102, 126, 234, 0.1); }
        #upload-area.hidden { display: none; }
        h1 { font-size: 2rem; margin-bottom: 1rem; 
             background: linear-gradient(135deg, #667eea, #764ba2);
             -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            border-radius: 20px;
            display: none;
            z-index: 20;
        }
        #controls.show { display: block; }
        .control-row {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1rem;
        }
        .control-row:last-child { margin-bottom: 0; }
        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            font-weight: 600;
        }
        button:hover { transform: scale(1.05); filter: brightness(1.2); }
        button.recording { background: #f44336; animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .slider-group {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .slider-group label {
            min-width: 110px;
            font-size: 0.85rem;
            opacity: 0.9;
        }
        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.5);
        }
        .value {
            min-width: 40px;
            text-align: right;
            font-size: 0.85rem;
            opacity: 0.8;
        }
        select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.9rem;
        }
        #status {
            flex: 1;
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.8;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        #beatIndicator {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(102, 126, 234, 0.3);
            z-index: 30;
            transition: all 0.1s;
        }
        #beatIndicator.beat {
            background: rgba(102, 126, 234, 1);
            transform: scale(1.3);
            box-shadow: 0 0 30px rgba(102, 126, 234, 0.8);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="beatIndicator"></div>
    <div id="ui">
        <div id="upload-area">
            <h1>üé¨ Audiovisual Cinema</h1>
            <p>Drop an audio file to create cinematic visuals</p>
            <p style="opacity: 0.7; margin-top: 1rem; font-size: 0.9rem;">
                Flying camera motion ‚Ä¢ Beat-detected scene transitions ‚Ä¢ Real-time recording
            </p>
            <input type="file" id="fileInput" accept="audio/*" style="display: none;">
        </div>
    </div>
    <div id="controls">
        <div class="control-row">
            <button id="playBtn">‚ñ∂Ô∏è Play</button>
            <button id="recordBtn">‚è∫Ô∏è Record</button>
            <button id="downloadBtn" style="display:none;">üíæ Download Video</button>
            <div class="checkbox-group">
                <input type="checkbox" id="autoCutaway" checked>
                <label for="autoCutaway">üé¨ Auto Scene Cuts</label>
            </div>
            <span id="status">Ready</span>
        </div>
        <div class="control-row">
            <div class="slider-group">
                <label>üöÄ Zoom Speed</label>
                <input type="range" id="zoomSpeed" min="0" max="100" value="60">
                <span class="value" id="zoomSpeedVal">60</span>
            </div>
            <div class="slider-group">
                <label>üåÄ Rotation</label>
                <input type="range" id="rotation" min="0" max="100" value="40">
                <span class="value" id="rotationVal">40</span>
            </div>
        </div>
        <div class="control-row">
            <div class="slider-group">
                <label>üé® Color Shift</label>
                <input type="range" id="colorShift" min="0" max="100" value="50">
                <span class="value" id="colorShiftVal">50</span>
            </div>
            <div class="slider-group">
                <label>‚ö° Intensity</label>
                <input type="range" id="intensity" min="0" max="100" value="75">
                <span class="value" id="intensityVal">75</span>
            </div>
        </div>
        <div class="control-row">
            <div class="slider-group">
                <label>üéØ Beat Sensitivity</label>
                <input type="range" id="beatThreshold" min="0" max="100" value="65">
                <span class="value" id="beatThresholdVal">65</span>
            </div>
            <div class="slider-group">
                <label>üí´ Complexity</label>
                <input type="range" id="complexity" min="0" max="100" value="60">
                <span class="value" id="complexityVal">60</span>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2', { preserveDrawingBuffer: true });
        const uploadArea = document.getElementById('upload-area');
        const fileInput = document.getElementById('fileInput');
        const controls = document.getElementById('controls');
        const playBtn = document.getElementById('playBtn');
        const recordBtn = document.getElementById('recordBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const status = document.getElementById('status');
        const autoCutaway = document.getElementById('autoCutaway');
        const beatIndicator = document.getElementById('beatIndicator');

        let audioContext, analyser, source, audioBuffer;
        let isPlaying = false;
        let mediaRecorder, recordedChunks = [];
        let params = {
            zoomSpeed: 0.6,
            rotation: 0.4,
            colorShift: 0.5,
            intensity: 0.75,
            complexity: 0.6,
            beatThreshold: 0.65
        };

        // Beat detection state
        let beatHistory = [];
        let lastBeatTime = 0;
        let currentScene = 0;
        let sceneTransition = 0;

        // Setup sliders
        ['zoomSpeed', 'rotation', 'colorShift', 'intensity', 'complexity', 'beatThreshold'].forEach(id => {
            const slider = document.getElementById(id);
            const valueSpan = document.getElementById(id + 'Val');
            slider.addEventListener('input', (e) => {
                const val = e.target.value;
                valueSpan.textContent = val;
                params[id] = val / 100;
            });
        });

        // Resize canvas
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // Cinematic scene shaders with camera motion
        const scenes = [
            // Tunnel Flight
            `
            precision highp float;
            uniform vec2 resolution;
            uniform float time;
            uniform float bass, mid, treble;
            uniform float zoom, rotation, colorShift, intensity, complexity;
            
            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy - 0.5;
                uv.x *= resolution.x / resolution.y;
                
                // Camera motion - flying forward
                float z = zoom * 10.0 + bass * 3.0;
                uv /= z;
                uv += vec2(time * 0.3, 0.0);
                
                // Rotation
                float angle = rotation * 3.14 + time * 0.5;
                float c = cos(angle), s = sin(angle);
                uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
                
                float dist = length(uv);
                float a = atan(uv.y, uv.x);
                
                // Tunnel rings
                float tunnel = sin(dist * 10.0 * complexity - time * 3.0 + bass * 5.0);
                tunnel += sin(a * 8.0 + time * 2.0 + mid * 3.0);
                tunnel *= intensity;
                
                vec3 col = vec3(
                    0.5 + sin(tunnel + colorShift * 6.28 + bass) * 0.5,
                    0.5 + sin(tunnel + 2.09 + mid) * 0.5,
                    0.5 + sin(tunnel + 4.19 + treble) * 0.5
                );
                
                col *= (1.0 - dist * 0.3);
                col += bass * 0.4;
                
                gl_FragColor = vec4(col, 1.0);
            }
            `,
            // Spiral Galaxy
            `
            precision highp float;
            uniform vec2 resolution;
            uniform float time;
            uniform float bass, mid, treble;
            uniform float zoom, rotation, colorShift, intensity, complexity;
            
            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy - 0.5;
                uv.x *= resolution.x / resolution.y;
                
                // Zoom in/out
                uv *= (2.0 - zoom);
                
                float dist = length(uv);
                float angle = atan(uv.y, uv.x);
                
                // Rotating spiral
                float spiral = angle + dist * 5.0 * complexity - time * rotation * 2.0;
                spiral += sin(dist * 10.0 - time * 2.0 + bass * 5.0) * 0.5;
                
                float arms = sin(spiral * 4.0 + bass * 2.0) * intensity;
                arms += sin(spiral * 8.0 + mid * 2.0) * 0.5;
                
                float brightness = arms / (dist * 2.0 + 0.1);
                
                vec3 col = vec3(
                    brightness * (0.5 + sin(time + colorShift * 6.28) * 0.5),
                    brightness * (0.5 + sin(time + 2.09 + mid) * 0.5),
                    brightness * (0.5 + sin(time + 4.19 + treble) * 0.5)
                );
                
                gl_FragColor = vec4(col, 1.0);
            }
            `,
            // Fractal Zoom
            `
            precision highp float;
            uniform vec2 resolution;
            uniform float time;
            uniform float bass, mid, treble;
            uniform float zoom, rotation, colorShift, intensity, complexity;
            
            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy - 0.5;
                uv.x *= resolution.x / resolution.y;
                
                // Deep zoom
                float scale = 1.0 / (zoom * 5.0 + bass * 2.0);
                uv *= scale;
                uv += vec2(cos(time * 0.3) * 0.5, sin(time * 0.2) * 0.5);
                
                // Rotate
                float a = rotation * 3.14 + time * 0.3;
                float c = cos(a), s = sin(a);
                uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
                
                vec2 z = uv;
                float iter = 0.0;
                for(float i = 0.0; i < 32.0; i++) {
                    if(i >= complexity * 32.0) break;
                    z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + uv;
                    if(length(z) > 4.0) break;
                    iter = i;
                }
                
                float val = iter / (complexity * 32.0) * intensity;
                val += bass * 0.3;
                
                vec3 col = vec3(
                    sin(val * 3.0 + colorShift * 6.28 + bass) * 0.5 + 0.5,
                    sin(val * 3.0 + 2.09 + mid) * 0.5 + 0.5,
                    sin(val * 3.0 + 4.19 + treble) * 0.5 + 0.5
                );
                
                gl_FragColor = vec4(col, 1.0);
            }
            `,
            // Warp Speed Stars
            `
            precision highp float;
            uniform vec2 resolution;
            uniform float time;
            uniform float bass, mid, treble;
            uniform float zoom, rotation, colorShift, intensity, complexity;
            
            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }
            
            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy - 0.5;
                uv.x *= resolution.x / resolution.y;
                
                // Rotation
                float angle = rotation * 3.14 + time * 0.5;
                float c = cos(angle), s = sin(angle);
                uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
                
                vec3 col = vec3(0.0);
                float speed = zoom * 3.0 + bass * 2.0;
                
                // Star field with motion blur
                for(float i = 0.0; i < 100.0; i++) {
                    if(i >= complexity * 100.0) break;
                    
                    vec2 starPos = vec2(
                        hash(vec2(i, 0.0)) - 0.5,
                        hash(vec2(i, 1.0)) - 0.5
                    ) * 3.0;
                    
                    float depth = hash(vec2(i, 2.0));
                    float z = mod(depth - time * speed * 0.5, 1.0);
                    
                    vec2 pos = starPos / z;
                    float stretch = speed * (1.0 - z) * 0.3;
                    
                    // Star streak
                    vec2 diff = uv - pos;
                    float d = length(diff);
                    float streak = length(vec2(diff.x, diff.y / (1.0 + stretch)));
                    
                    float brightness = 0.002 / streak * intensity;
                    brightness *= (1.0 - z);
                    
                    vec3 starCol = vec3(
                        sin(i * 0.1 + colorShift * 6.28 + bass) * 0.5 + 0.5,
                        sin(i * 0.13 + mid) * 0.5 + 0.5,
                        sin(i * 0.17 + treble) * 0.5 + 0.5
                    );
                    
                    col += starCol * brightness;
                }
                
                gl_FragColor = vec4(col, 1.0);
            }
            `,
            // Kaleidoscope Vortex
            `
            precision highp float;
            uniform vec2 resolution;
            uniform float time;
            uniform float bass, mid, treble;
            uniform float zoom, rotation, colorShift, intensity, complexity;
            
            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy - 0.5;
                uv.x *= resolution.x / resolution.y;
                
                // Zoom
                uv /= (zoom * 2.0 + bass * 0.5);
                
                float dist = length(uv);
                float angle = atan(uv.y, uv.x);
                
                // Kaleidoscope effect
                float segments = 6.0 + floor(complexity * 8.0);
                angle = mod(angle, 6.28 / segments);
                angle = abs(angle - 3.14 / segments);
                
                // Rotate
                angle += time * rotation + bass * 0.5;
                
                // Reconstruct UV
                vec2 kaleido = vec2(cos(angle), sin(angle)) * dist;
                
                // Vortex distortion
                float vortex = sin(dist * 10.0 - time * 2.0 + bass * 3.0);
                vortex += cos(angle * 8.0 + time + mid * 2.0);
                vortex *= intensity;
                
                vec3 col = vec3(
                    sin(vortex + kaleido.x * 5.0 + colorShift * 6.28) * 0.5 + 0.5,
                    sin(vortex + kaleido.y * 5.0 + mid) * 0.5 + 0.5,
                    sin(vortex + dist * 10.0 + treble) * 0.5 + 0.5
                );
                
                col *= (1.0 - dist * 0.5);
                
                gl_FragColor = vec4(col, 1.0);
            }
            `
        ];

        // Compile shaders
        const programs = [];
        const vertexShaderSource = `
            attribute vec2 position;
            void main() { gl_Position = vec4(position, 0.0, 1.0); }
        `;
        
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);

        scenes.forEach((fragSource) => {
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragSource);
            gl.compileShader(fragmentShader);
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            programs.push({
                program: program,
                uniforms: {
                    resolution: gl.getUniformLocation(program, 'resolution'),
                    time: gl.getUniformLocation(program, 'time'),
                    bass: gl.getUniformLocation(program, 'bass'),
                    mid: gl.getUniformLocation(program, 'mid'),
                    treble: gl.getUniformLocation(program, 'treble'),
                    zoom: gl.getUniformLocation(program, 'zoom'),
                    rotation: gl.getUniformLocation(program, 'rotation'),
                    colorShift: gl.getUniformLocation(program, 'colorShift'),
                    intensity: gl.getUniformLocation(program, 'intensity'),
                    complexity: gl.getUniformLocation(program, 'complexity')
                }
            });
        });

        // Setup quad
        const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        // Audio setup
        function setupAudio(arrayBuffer) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            
            audioContext.decodeAudioData(arrayBuffer, (buffer) => {
                audioBuffer = buffer;
                uploadArea.classList.add('hidden');
                controls.classList.add('show');
                status.textContent = `Loaded ‚Ä¢ ${buffer.duration.toFixed(1)}s`;
            });
        }

        function play() {
            if (!audioBuffer) return;
            
            if (isPlaying) {
                source.stop();
                isPlaying = false;
                playBtn.textContent = '‚ñ∂Ô∏è Play';
                return;
            }
            
            source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(analyser);
            analyser.connect(audioContext.destination);
            source.start();
            isPlaying = true;
            playBtn.textContent = '‚è∏Ô∏è Pause';
            
            source.onended = () => {
                isPlaying = false;
                playBtn.textContent = '‚ñ∂Ô∏è Play';
            };
        }

        // Beat detection
        function detectBeat(bass, mid) {
            const now = performance.now();
            const energy = bass * 0.7 + mid * 0.3;
            
            beatHistory.push(energy);
            if (beatHistory.length > 30) beatHistory.shift();
            
            const avg = beatHistory.reduce((a, b) => a + b, 0) / beatHistory.length;
            const threshold = avg * (1.0 + params.beatThreshold);
            
            if (energy > threshold && now - lastBeatTime > 300) {
                lastBeatTime = now;
                
                // Visual beat indicator
                beatIndicator.classList.add('beat');
                setTimeout(() => beatIndicator.classList.remove('beat'), 100);
                
                // Scene transition on beat
                if (autoCutaway.checked) {
                    currentScene = (currentScene + 1) % programs.length;
                    sceneTransition = 1.0;
                }
                
                return true;
            }
            return false;
        }

        // Recording
        let captureStream;
        function startRecording() {
            if (!captureStream) {
                captureStream = canvas.captureStream(60);
                const audioStream = audioContext.createMediaStreamDestination();
                analyser.connect(audioStream);
                captureStream.addTrack(audioStream.stream.getAudioTracks()[0]);
            }
            
            recordedChunks = [];
            mediaRecorder = new MediaRecorder(captureStream, {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 8000000
            });
            
            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) recordedChunks.push(e.data);
            };
            
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `cinema-${Date.now()}.webm`;
                downloadBtn.onclick = () => a.click();
                downloadBtn.style.display = 'block';
                recordBtn.classList.remove('recording');
                recordBtn.textContent = '‚è∫Ô∏è Record';
            };
            
            mediaRecorder.start();
            recordBtn.classList.add('recording');
            recordBtn.textContent = '‚èπÔ∏è Stop Recording';
            play();
        }

        recordBtn.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            } else {
                startRecording();
            }
        });

        // Render loop
        function render() {
            const dataArray = new Uint8Array(analyser ? analyser.frequencyBinCount : 256);
            if (analyser) analyser.getByteFrequencyData(dataArray);
            
            const bass = dataArray.slice(0, 20).reduce((a, b) => a + b, 0) / 20 / 255;
            const mid = dataArray.slice(20, 100).reduce((a, b) => a + b, 0) / 80 / 255;
            const treble = dataArray.slice(100, 200).reduce((a, b) => a + b, 0) / 100 / 255;
            
            // Beat detection
            if (isPlaying) {
                detectBeat(bass, mid);
            }
            
            // Smooth scene transition
            sceneTransition = Math.max(0, sceneTransition - 0.02);
            
            const currentProgram = programs[currentScene];
            gl.useProgram(currentProgram.program);
            
            const posLoc = gl.getAttribLocation(currentProgram.program, 'position');
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            
            gl.uniform2f(currentProgram.uniforms.resolution, canvas.width, canvas.height);
            gl.uniform1f(currentProgram.uniforms.time, performance.now() / 1000);
            gl.uniform1f(currentProgram.uniforms.bass, bass);
            gl.uniform1f(currentProgram.uniforms.mid, mid);
            gl.uniform1f(currentProgram.uniforms.treble, treble);
            gl.uniform1f(currentProgram.uniforms.zoom, params.zoomSpeed + bass * 0.3);
            gl.uniform1f(currentProgram.uniforms.rotation, params.rotation);
            gl.uniform1f(currentProgram.uniforms.colorShift, params.colorShift);
            gl.uniform1f(currentProgram.uniforms.intensity, params.intensity);
            gl.uniform1f(currentProgram.uniforms.complexity, params.complexity);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(render);
        }
        render();

        // File handling
        uploadArea.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) {
                const reader = new FileReader();
                reader.onload = (e) => setupAudio(e.target.result);
                reader.readAsArrayBuffer(e.target.files[0]);
            }
        });

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = '#667eea';
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => setupAudio(e.target.result);
                reader.readAsArrayBuffer(file);
            }
        });

        playBtn.addEventListener('click', play);
    </script>
</body>
</html>
