<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio1.TV - AI Music Video Generator</title>
    
    <!-- Modern Design System -->
    <link rel="stylesheet" href="audio1tv-modern.css">
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="recipe-generator.js"></script>
    <script src="narrative-recipe-generator.js"></script>
    
    <style>
        /* Component-specific overrides */
        .upload-zone {
            min-height: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 2px dashed var(--border-medium);
            border-radius: var(--radius-xl);
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            transition: all var(--transition-base);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .upload-zone::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 50% 50%,
                oklch(47.6% 0.152 294 / 0.1),
                transparent 70%
            );
            opacity: 0;
            transition: opacity var(--transition-base);
        }
        
        .upload-zone.dragover {
            border-color: var(--primary-light);
            background: oklch(20% 0.05 294 / 0.8);
        }
        
        .upload-zone.dragover::before {
            opacity: 1;
        }
        
        .upload-icon {
            font-size: 4rem;
            margin-bottom: var(--space-lg);
            opacity: 0.5;
        }
        
        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 50%,
                oklch(15% 0.04 294),
                var(--bg-primary)
            );
        }
        
        canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
        }
        
        .waveform-container {
            width: 100%;
            height: 120px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            overflow: hidden;
            position: relative;
        }
        
        .beat-markers {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }
        
        .beat-marker {
            position: absolute;
            width: 2px;
            height: 100%;
            background: var(--accent);
            opacity: 0.4;
        }
        
        .section-label {
            position: absolute;
            top: 0.5rem;
            padding: 0.25rem 0.5rem;
            background: oklch(20% 0.02 294 / 0.8);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-sm);
            font-size: 0.65rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- HEADER -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <header class="app-header">
            <div class="logo-section">
                <div class="logo">Audio1.TV</div>
                <div class="version-badge">v2.0 AI</div>
            </div>
            
            <div class="nav-section">
                <div class="status-indicator">
                    <div class="status-dot active" id="aiStatusDot"></div>
                    <span id="aiStatusText">AI Ready</span>
                </div>
                
                <button class="btn btn-ghost" onclick="showSettings()">
                    <span>âš™ï¸</span> Settings
                </button>
                
                <button class="btn btn-accent" onclick="triggerUpload()" id="uploadBtn">
                    <span>ğŸ“</span> Upload Audio
                </button>
            </div>
        </header>
        
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- MAIN CONTENT -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <main id="mainContent">
            <!-- Upload View (Initial State) -->
            <div id="uploadView" class="upload-zone" style="margin: 2rem; height: calc(100vh - 200px);">
                <div class="upload-icon">ğŸµ</div>
                <h2 class="text-gradient" style="font-size: 2rem; margin-bottom: 1rem;">
                    Drop Your Audio Here
                </h2>
                <p style="color: var(--text-secondary); margin-bottom: 2rem;">
                    AI will analyze and create a professional music video
                </p>
                <button class="btn btn-primary" onclick="triggerUpload()">
                    Choose Audio File
                </button>
                <input type="file" id="audioInput" accept="audio/*" style="display: none;" onchange="handleAudioUpload(event)">
            </div>
            
            <!-- Canvas View (After Upload) -->
            <div id="canvasView" class="canvas-container" style="display: none;">
                <canvas id="bgCanvas"></canvas>
                <canvas id="canvas3d"></canvas>
                <canvas id="visualCanvas"></canvas>
                
                <!-- AI Analysis Panel -->
                <div class="panel panel-analysis" id="analysisPanel" style="display: none;">
                    <div class="card-header">
                        <div class="card-title">ğŸ¤– AI Analysis</div>
                        <div class="card-subtitle">Understanding your music...</div>
                    </div>
                    
                    <div id="aiThoughts" style="font-size: 0.85rem; color: var(--text-secondary);">
                        <!-- AI thoughts populate here -->
                    </div>
                    
                    <div class="metrics-grid" style="margin-top: 1.5rem;">
                        <div class="metric-item">
                            <div class="metric-value" id="bpmValue">--</div>
                            <div class="metric-label">BPM</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" id="beatCount">--</div>
                            <div class="metric-label">Beats</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" id="energyValue">--</div>
                            <div class="metric-label">Energy</div>
                        </div>
                    </div>
                    
                    <button class="btn btn-accent" style="width: 100%; margin-top: 1.5rem;" onclick="showAnalysisModal()">
                        <span>âœ¨</span> View Full Analysis
                    </button>
                </div>
                
                <!-- Timeline Panel -->
                <div class="panel panel-timeline" id="timelinePanel" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <div class="card-title">Timeline</div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-ghost btn-icon" onclick="playPause()">â–¶ï¸</button>
                            <button class="btn btn-ghost btn-icon" onclick="resetPlayback()">â¹ï¸</button>
                        </div>
                    </div>
                    
                    <div class="waveform-container" id="waveformContainer">
                        <div class="beat-markers" id="beatMarkers"></div>
                        <!-- Waveform visualization -->
                    </div>
                    
                    <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                        <div style="flex: 1;">
                            <div style="font-size: 0.75rem; color: var(--text-tertiary); margin-bottom: 0.25rem;">
                                CURRENT TIME
                            </div>
                            <div style="font-size: 1.2rem; font-weight: 700; color: var(--text-primary);" id="currentTime">
                                0:00
                            </div>
                        </div>
                        <div style="flex: 1;">
                            <div style="font-size: 0.75rem; color: var(--text-tertiary); margin-bottom: 0.25rem;">
                                DURATION
                            </div>
                            <div style="font-size: 1.2rem; font-weight: 700; color: var(--text-primary);" id="duration">
                                0:00
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
    
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <!-- ANALYSIS MODAL -->
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div id="analysisModal" class="analysis-modal">
        <div class="analysis-content">
            <div class="analysis-header">
                <h2>ğŸµ Audio Analysis Complete</h2>
                <p>Here's what I understand about your music. Ready to generate?</p>
            </div>

            <!-- Basic Stats Grid -->
            <div class="analysis-grid">
                <div class="analysis-card">
                    <h3><span class="icon">ğŸ“Š</span> Audio Metrics</h3>
                    <div class="stat-row">
                        <span class="stat-label">Duration</span>
                        <span class="stat-value" id="stat-duration">--</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">BPM</span>
                        <span class="stat-value" id="stat-bpm">--</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Total Beats</span>
                        <span class="stat-value" id="stat-beats">--</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Avg Energy</span>
                        <span class="stat-value" id="stat-energy">--</span>
                    </div>
                    <div class="energy-bar">
                        <div class="energy-fill" id="energy-fill" style="width: 0%"></div>
                    </div>
                </div>

                <div class="analysis-card">
                    <h3><span class="icon">ğŸ¼</span> Song Structure</h3>
                    <div class="stat-row">
                        <span class="stat-label">Sections Detected</span>
                        <span class="stat-value" id="stat-sections">--</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Complexity</span>
                        <span class="stat-value" id="stat-complexity">--</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Mood</span>
                        <div id="mood-badges"></div>
                    </div>
                </div>

                <div class="analysis-card">
                    <h3><span class="icon">ğŸ›ï¸</span> Audio Patterns</h3>
                    <div class="stat-row">
                        <span class="stat-label">Rhythm Complexity</span>
                        <span class="stat-value" id="stat-rhythm">--</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Harmonic Density</span>
                        <span class="stat-value" id="stat-harmonic">--</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Spectral Centroid</span>
                        <span class="stat-value" id="stat-spectral">--</span>
                    </div>
                </div>
            </div>

            <!-- Structure Timeline -->
            <div class="analysis-card">
                <h3><span class="icon">â±ï¸</span> Structure Timeline</h3>
                <div class="structure-timeline" id="structure-timeline"></div>
            </div>

            <!-- Narrative Preview -->
            <div class="narrative-preview">
                <h3>ğŸ¬ Recommended Narrative Structure</h3>
                <div class="narrative-type" id="narrative-type">Visual Ensemble</div>
                <p id="narrative-description" style="color: rgba(255,255,255,0.8); margin-bottom: 1rem;">
                    Multiple visual themes will share equal presence throughout the video.
                </p>
                
                <h4 style="color: var(--accent); margin-top: 1.5rem; margin-bottom: 0.8rem;">Visual Characters:</h4>
                <div class="visual-characters" id="visual-characters"></div>
            </div>

            <!-- Action Buttons -->
            <div class="action-buttons">
                <button class="btn btn-ghost" onclick="closeAnalysisModal()">
                    â† Back to Edit
                </button>
                <button class="btn btn-accent" onclick="generateFromAnalysis()">
                    Generate Video Recipe â†’
                </button>
            </div>
        </div>
    </div>
    
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <!-- AI ENGINE -->
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STATE MANAGEMENT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const STATE = {
            audioFile: null,
            audioBuffer: null,
            audioContext: null,
            analyzerNode: null,
            sourceNode: null,
            
            // Analysis Results
            duration: 0,
            bpm: 0,
            beats: [],
            energyCurve: [],
            structure: [],
            audioPatterns: null,
            
            // Recipe
            recipe: null,
            narrativeStructure: null,
            
            // Playback
            isPlaying: false,
            currentTime: 0,
            startTime: 0
        };
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // AGENTCACHE.AI CONFIGURATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const AGENTCACHE_CONFIG = {
            apiKey: 'ac_demo_test123',
            baseUrl: 'https://agentcache.ai/api',
            namespace: 'audio1tv',
            ttl: 30 * 24 * 60 * 60 // 30 days
        };
        
        async function hashAudioBuffer(buffer) {
            const data = new Float32Array([
                buffer.duration,
                buffer.sampleRate,
                buffer.numberOfChannels,
                ...Array.from(buffer.getChannelData(0).slice(0, 50))
            ]);
            
            const hashBuffer = await crypto.subtle.digest('SHA-256', data.buffer);
            return Array.from(new Uint8Array(hashBuffer))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }
        
        async function checkAudioCache(fingerprint) {
            try {
                const response = await fetch(`${AGENTCACHE_CONFIG.baseUrl}/cache/get`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': AGENTCACHE_CONFIG.apiKey
                    },
                    body: JSON.stringify({
                        namespace: AGENTCACHE_CONFIG.namespace,
                        key: fingerprint
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.value) {
                        console.log('âš¡ Cache hit! Loading instant results...');
                        return JSON.parse(data.value);
                    }
                }
            } catch (error) {
                console.warn('Cache check failed:', error);
            }
            return null;
        }
        
        async function cacheAudioAnalysis(fingerprint, analysisData) {
            try {
                await fetch(`${AGENTCACHE_CONFIG.baseUrl}/cache/set`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': AGENTCACHE_CONFIG.apiKey
                    },
                    body: JSON.stringify({
                        namespace: AGENTCACHE_CONFIG.namespace,
                        key: fingerprint,
                        value: JSON.stringify(analysisData),
                        ttl: AGENTCACHE_CONFIG.ttl
                    })
                });
                console.log('ğŸ’¾ Analysis cached for future use');
            } catch (error) {
                console.warn('Caching failed:', error);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // AUDIO UPLOAD & PROCESSING
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function triggerUpload() {
            document.getElementById('audioInput').click();
        }
        
        async function handleAudioUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            STATE.audioFile = file;
            updateStatus('processing', 'Analyzing audio...');
            
            // Switch to canvas view
            document.getElementById('uploadView').style.display = 'none';
            document.getElementById('canvasView').style.display = 'block';
            document.getElementById('analysisPanel').style.display = 'block';
            document.getElementById('timelinePanel').style.display = 'block';
            
            // Initialize audio context
            STATE.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Load and decode audio
            const arrayBuffer = await file.arrayBuffer();
            STATE.audioBuffer = await STATE.audioContext.decodeAudioData(arrayBuffer);
            STATE.duration = STATE.audioBuffer.duration;
            
            // Check cache first
            const fingerprint = await hashAudioBuffer(STATE.audioBuffer);
            const cachedAnalysis = await checkAudioCache(fingerprint);
            
            if (cachedAnalysis) {
                // Load from cache
                STATE.beats = cachedAnalysis.beats;
                STATE.bpm = cachedAnalysis.bpm;
                STATE.energyCurve = cachedAnalysis.energyCurve;
                STATE.structure = cachedAnalysis.structure;
                STATE.audioPatterns = cachedAnalysis.audioPatterns;
                
                addAIThought('âš¡ Loaded analysis from cache (instant!)');
                displayAnalysisResults();
            } else {
                // Perform analysis
                await analyzeAudio();
                
                // Cache results
                await cacheAudioAnalysis(fingerprint, {
                    beats: STATE.beats,
                    bpm: STATE.bpm,
                    energyCurve: STATE.energyCurve,
                    structure: STATE.structure,
                    audioPatterns: STATE.audioPatterns
                });
            }
            
            // Update UI
            updateStatus('active', 'Analysis complete');
            document.getElementById('duration').textContent = formatTime(STATE.duration);
            
            // Initialize visualizations
            initializeVisualizations();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // AUDIO ANALYSIS ENGINE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function analyzeAudio() {
            addAIThought('ğŸµ Analyzing audio structure...');
            
            const channelData = STATE.audioBuffer.getChannelData(0);
            const sampleRate = STATE.audioBuffer.sampleRate;
            
            // Beat detection
            addAIThought('ğŸ¥ Detecting beats and tempo...');
            STATE.beats = detectBeats(channelData, sampleRate);
            STATE.bpm = calculateBPM(STATE.beats);
            
            // Energy curve
            addAIThought('âš¡ Computing energy curve...');
            STATE.energyCurve = computeEnergyCurve(channelData, sampleRate);
            
            // Structure detection
            addAIThought('ğŸ¼ Identifying song structure...');
            STATE.structure = detectStructure(STATE.energyCurve, STATE.beats, STATE.duration);
            
            // Audio patterns
            addAIThought('ğŸ›ï¸ Analyzing audio patterns...');
            STATE.audioPatterns = analyzePatterns(channelData, sampleRate, STATE.beats);
            
            addAIThought('âœ… Analysis complete!');
        }
        
        function detectBeats(channelData, sampleRate) {
            const beats = [];
            const windowSize = Math.floor(sampleRate * 0.05); // 50ms window
            const hopSize = Math.floor(windowSize / 2);
            
            // Compute energy in windows
            const energies = [];
            for (let i = 0; i < channelData.length - windowSize; i += hopSize) {
                let energy = 0;
                for (let j = 0; j < windowSize; j++) {
                    energy += channelData[i + j] ** 2;
                }
                energies.push(energy / windowSize);
            }
            
            // Find peaks
            const threshold = energies.reduce((a, b) => a + b) / energies.length * 1.5;
            for (let i = 1; i < energies.length - 1; i++) {
                if (energies[i] > threshold &&
                    energies[i] > energies[i - 1] &&
                    energies[i] > energies[i + 1]) {
                    beats.push((i * hopSize) / sampleRate);
                }
            }
            
            return beats;
        }
        
        function calculateBPM(beats) {
            if (beats.length < 2) return 120;
            
            const intervals = [];
            for (let i = 1; i < beats.length; i++) {
                intervals.push(beats[i] - beats[i - 1]);
            }
            
            const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
            return Math.round(60 / avgInterval);
        }
        
        function computeEnergyCurve(channelData, sampleRate) {
            const curve = [];
            const windowSize = Math.floor(sampleRate * 0.1); // 100ms
            
            for (let i = 0; i < channelData.length; i += windowSize) {
                let energy = 0;
                const end = Math.min(i + windowSize, channelData.length);
                for (let j = i; j < end; j++) {
                    energy += Math.abs(channelData[j]);
                }
                curve.push(energy / windowSize);
            }
            
            // Normalize
            const max = Math.max(...curve);
            return curve.map(e => e / max);
        }
        
        function detectStructure(energyCurve, beats, duration) {
            const structure = [];
            const segmentDuration = 8; // seconds
            const numSegments = Math.ceil(duration / segmentDuration);
            
            for (let i = 0; i < numSegments; i++) {
                const start = i * segmentDuration;
                const end = Math.min((i + 1) * segmentDuration, duration);
                
                const startIdx = Math.floor((start / duration) * energyCurve.length);
                const endIdx = Math.floor((end / duration) * energyCurve.length);
                const segmentEnergy = energyCurve.slice(startIdx, endIdx);
                const avgEnergy = segmentEnergy.reduce((a, b) => a + b, 0) / segmentEnergy.length;
                
                let type = 'verse';
                if (avgEnergy > 0.8) type = 'drop';
                else if (avgEnergy > 0.6) type = 'chorus';
                else if (avgEnergy < 0.3) type = 'intro';
                
                structure.push({ start, end, type, energy: avgEnergy });
            }
            
            return structure;
        }
        
        function analyzePatterns(channelData, sampleRate, beats) {
            // Rhythm complexity
            const beatIntervals = [];
            for (let i = 1; i < beats.length; i++) {
                beatIntervals.push(beats[i] - beats[i - 1]);
            }
            const rhythmVariance = variance(beatIntervals);
            const rhythmComplexity = Math.min(100, rhythmVariance * 1000);
            
            // Harmonic complexity (simplified)
            const harmonicComplexity = Math.min(100, Math.random() * 50 + 30); // Placeholder
            
            // Spectral centroid (placeholder)
            const spectralCentroid = Math.round(Math.random() * 2000 + 1000);
            
            return {
                rhythmComplexity: Math.round(rhythmComplexity),
                harmonicComplexity: Math.round(harmonicComplexity),
                spectralCentroid
            };
        }
        
        function variance(arr) {
            const mean = arr.reduce((a, b) => a + b) / arr.length;
            return arr.reduce((sum, val) => sum + (val - mean) ** 2, 0) / arr.length;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UI UPDATES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function updateStatus(status, text) {
            const dot = document.getElementById('aiStatusDot');
            const textEl = document.getElementById('aiStatusText');
            
            dot.className = `status-dot ${status}`;
            textEl.textContent = text;
        }
        
        function addAIThought(thought) {
            const container = document.getElementById('aiThoughts');
            const div = document.createElement('div');
            div.className = 'animate-fade-in';
            div.style.cssText = 'font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.5rem;';
            div.textContent = thought;
            container.appendChild(div);
            
            // Keep only last 5 thoughts
            while (container.children.length > 5) {
                container.removeChild(container.firstChild);
            }
        }
        
        function displayAnalysisResults() {
            // Update metrics
            document.getElementById('bpmValue').textContent = STATE.bpm;
            document.getElementById('beatCount').textContent = STATE.beats.length;
            const avgEnergy = STATE.energyCurve.reduce((a, b) => a + b) / STATE.energyCurve.length;
            document.getElementById('energyValue').textContent = `${Math.round(avgEnergy * 100)}%`;
            
            // Draw beat markers
            drawBeatMarkers();
        }
        
        function drawBeatMarkers() {
            const container = document.getElementById('beatMarkers');
            container.innerHTML = '';
            
            STATE.beats.forEach(beatTime => {
                const marker = document.createElement('div');
                marker.className = 'beat-marker';
                marker.style.left = `${(beatTime / STATE.duration) * 100}%`;
                container.appendChild(marker);
            });
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ANALYSIS MODAL (from analysis-modal.html)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        let currentAnalysisData = null;
        
        function showAnalysisModal() {
            currentAnalysisData = {
                duration: STATE.duration,
                bpm: STATE.bpm,
                beats: STATE.beats,
                structure: STATE.structure,
                audioPatterns: STATE.audioPatterns
            };
            
            // Populate modal
            document.getElementById('stat-duration').textContent = formatTime(STATE.duration);
            document.getElementById('stat-bpm').textContent = STATE.bpm || 'Unknown';
            document.getElementById('stat-beats').textContent = STATE.beats.length;
            
            const avgEnergy = STATE.energyCurve.reduce((a, b) => a + b) / STATE.energyCurve.length;
            document.getElementById('stat-energy').textContent = `${Math.round(avgEnergy * 100)}%`;
            document.getElementById('energy-fill').style.width = `${avgEnergy * 100}%`;
            
            document.getElementById('stat-sections').textContent = STATE.structure.length;
            const complexity = STATE.structure.length >= 5 ? 'High' : 
                               STATE.structure.length >= 3 ? 'Medium' : 'Simple';
            document.getElementById('stat-complexity').textContent = complexity;
            
            // Mood badges
            const moods = determineMoods(currentAnalysisData);
            document.getElementById('mood-badges').innerHTML = moods.map(m => 
                `<span class="mood-badge">${m}</span>`
            ).join('');
            
            // Audio patterns
            if (STATE.audioPatterns) {
                document.getElementById('stat-rhythm').textContent = STATE.audioPatterns.rhythmComplexity;
                document.getElementById('stat-harmonic').textContent = STATE.audioPatterns.harmonicComplexity;
                document.getElementById('stat-spectral').textContent = STATE.audioPatterns.spectralCentroid;
            }
            
            // Structure timeline
            const timeline = document.getElementById('structure-timeline');
            timeline.innerHTML = STATE.structure.map(section => {
                const width = ((section.end - section.start) / STATE.duration) * 100;
                return `<div class="structure-segment ${section.type}" style="flex-basis: ${width}%">${section.type.toUpperCase()}</div>`;
            }).join('');
            
            // Narrative recommendation
            const narrative = recommendNarrative(currentAnalysisData);
            document.getElementById('narrative-type').textContent = narrative.name;
            document.getElementById('narrative-description').textContent = narrative.description;
            
            const charContainer = document.getElementById('visual-characters');
            charContainer.innerHTML = narrative.visualCast.map(char => `
                <div class="character-chip" style="border-color: ${char.color}">
                    <div class="color-dot" style="background: ${char.color}"></div>
                    <span>${char.name}</span>
                    <span class="presence">${char.presence}%</span>
                </div>
            `).join('');
            
            document.getElementById('analysisModal').classList.add('active');
        }
        
        function closeAnalysisModal() {
            document.getElementById('analysisModal').classList.remove('active');
        }
        
        function generateFromAnalysis() {
            closeAnalysisModal();
            updateStatus('processing', 'Generating recipe...');
            
            // TODO: Integrate with recipe-generator.js and narrative-recipe-generator.js
            console.log('ğŸ¬ Generating recipe from analysis:', currentAnalysisData);
            
            // Simulate recipe generation
            setTimeout(() => {
                STATE.recipe = {
                    shot_list: [],
                    visual_style: {},
                    assembly_instructions: {}
                };
                
                updateStatus('active', 'Recipe ready!');
                alert('Recipe generation complete! Next: Mochi + Gaussian Splat pipeline');
            }, 2000);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // HELPER FUNCTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        function determineMoods(analysisData) {
            const moods = [];
            const avgEnergy = analysisData.structure.reduce((sum, s) => sum + s.energy, 0) / analysisData.structure.length;
            const bpm = analysisData.bpm || 120;
            
            if (avgEnergy > 0.8 && bpm > 120) moods.push('ğŸ”¥ Intense');
            if (avgEnergy > 0.6 && bpm > 110) moods.push('âš¡ Energetic');
            if (avgEnergy < 0.4) moods.push('ğŸ˜Œ Chill');
            if (bpm > 140) moods.push('ğŸƒ Fast');
            if (bpm < 90) moods.push('ğŸš¶ Slow');
            
            const hasDrops = analysisData.structure.some(s => s.type === 'drop');
            if (hasDrops) moods.push('ğŸ’¥ Drop');
            
            return moods.length > 0 ? moods : ['ğŸµ Balanced'];
        }
        
        function recommendNarrative(analysisData) {
            const avgEnergy = analysisData.structure.reduce((sum, s) => sum + s.energy, 0) / analysisData.structure.length;
            const complexity = analysisData.structure.length;
            
            if (avgEnergy > 0.8 && complexity <= 3) {
                return {
                    name: 'Hyper-Present Hero',
                    description: 'One dominant visual motif will appear in almost every shot, creating intense focus.',
                    visualCast: [
                        { name: 'Neon Hero', color: '#ff006e', presence: 95 },
                        { name: 'Particle Support', color: '#00ff88', presence: 20 }
                    ]
                };
            } else if (complexity >= 5) {
                return {
                    name: 'Episodic Segments',
                    description: 'Distinct visual chapters will unfold, each with its own unique aesthetic.',
                    visualCast: [
                        { name: 'Neon Hero', color: '#ff006e', presence: 33 },
                        { name: 'Liquid Protagonist', color: '#457b9d', presence: 33 },
                        { name: 'Particle Ensemble', color: '#00ff88', presence: 33 },
                        { name: 'Camera Narrator', color: '#00f5ff', presence: 100 }
                    ]
                };
            } else if (avgEnergy > 0.5 && complexity >= 4) {
                return {
                    name: 'Parallel Narratives',
                    description: 'Two visual stories will alternate and converge, creating dynamic contrast.',
                    visualCast: [
                        { name: 'Neon Hero', color: '#ff006e', presence: 50 },
                        { name: 'Liquid Protagonist', color: '#457b9d', presence: 50 },
                        { name: 'Glitch Bridge', color: '#ff0080', presence: 20 }
                    ]
                };
            } else {
                return {
                    name: 'Visual Ensemble',
                    description: 'Multiple visual themes will share equal presence throughout the video.',
                    visualCast: [
                        { name: 'Neon Hero', color: '#ff006e', presence: 70 },
                        { name: 'Liquid Protagonist', color: '#457b9d', presence: 65 },
                        { name: 'Particle Ensemble', color: '#00ff88', presence: 60 },
                        { name: 'Glitch Antagonist', color: '#ff0080', presence: 30 }
                    ]
                };
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PLAYBACK CONTROLS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function playPause() {
            if (!STATE.audioBuffer) return;
            
            if (STATE.isPlaying) {
                // Pause
                if (STATE.sourceNode) {
                    STATE.sourceNode.stop();
                    STATE.sourceNode = null;
                }
                STATE.isPlaying = false;
            } else {
                // Play
                STATE.sourceNode = STATE.audioContext.createBufferSource();
                STATE.sourceNode.buffer = STATE.audioBuffer;
                STATE.sourceNode.connect(STATE.audioContext.destination);
                STATE.sourceNode.start(0, STATE.currentTime);
                STATE.startTime = STATE.audioContext.currentTime - STATE.currentTime;
                STATE.isPlaying = true;
                
                updatePlaybackTime();
            }
        }
        
        function resetPlayback() {
            if (STATE.sourceNode) {
                STATE.sourceNode.stop();
                STATE.sourceNode = null;
            }
            STATE.isPlaying = false;
            STATE.currentTime = 0;
            document.getElementById('currentTime').textContent = '0:00';
        }
        
        function updatePlaybackTime() {
            if (!STATE.isPlaying) return;
            
            STATE.currentTime = STATE.audioContext.currentTime - STATE.startTime;
            document.getElementById('currentTime').textContent = formatTime(STATE.currentTime);
            
            if (STATE.currentTime < STATE.duration) {
                requestAnimationFrame(updatePlaybackTime);
            } else {
                STATE.isPlaying = false;
                STATE.currentTime = 0;
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // VISUALIZATIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function initializeVisualizations() {
            const bgCanvas = document.getElementById('bgCanvas');
            const ctx = bgCanvas.getContext('2d');
            
            function resize() {
                bgCanvas.width = window.innerWidth;
                bgCanvas.height = window.innerHeight;
            }
            resize();
            window.addEventListener('resize', resize);
            
            function animate() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
                
                // Draw audio-reactive visualization
                if (STATE.energyCurve.length > 0) {
                    const energy = STATE.energyCurve[Math.floor((STATE.currentTime / STATE.duration) * STATE.energyCurve.length)] || 0;
                    
                    ctx.strokeStyle = `oklch(62% 0.152 294 / ${energy})`;
                    ctx.lineWidth = 2 + energy * 5;
                    ctx.beginPath();
                    
                    for (let i = 0; i < 100; i++) {
                        const angle = (i / 100) * Math.PI * 2;
                        const radius = 100 + energy * 200;
                        const x = bgCanvas.width / 2 + Math.cos(angle) * radius;
                        const y = bgCanvas.height / 2 + Math.sin(angle) * radius;
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }
                
                requestAnimationFrame(animate);
            }
            animate();
        }
        
        function showSettings() {
            alert('Settings panel coming soon!');
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DRAG & DROP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const uploadZone = document.getElementById('uploadView');
        
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });
        
        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });
        
        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('audio/')) {
                const input = document.getElementById('audioInput');
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                input.files = dataTransfer.files;
                handleAudioUpload({ target: input });
            }
        });
    </script>
</body>
</html>
