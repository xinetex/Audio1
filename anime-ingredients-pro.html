<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anime.js Layered Ingredient System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/meyda/5.6.0/meyda.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #choreographyLayer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        #ingredientLayer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none;
        }
        .ingredient {
            position: absolute;
            transform-origin: center;
            pointer-events: none;
        }
        .ingredient img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .particle {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #f093fb);
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
        }
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
        }
        #upload-area {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border: 3px dashed rgba(102, 126, 234, 0.5);
            border-radius: 25px;
            padding: 4rem 5rem;
            text-align: center;
            pointer-events: all;
            cursor: pointer;
            transition: all 0.4s;
        }
        #upload-area:hover { 
            border-color: #667eea; 
            background: rgba(102, 126, 234, 0.15);
            transform: scale(1.02);
        }
        #upload-area.hidden { display: none; }
        h1 { 
            font-size: 2.5rem; 
            margin-bottom: 1rem; 
            background: linear-gradient(135deg, #667eea, #764ba2, #f093fb);
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent;
            font-weight: 800;
        }
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            padding: 1.5rem;
            border-radius: 25px;
            border: 1px solid rgba(102, 126, 234, 0.3);
            display: none;
            z-index: 20;
        }
        #controls.show { display: block; }
        .control-row {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1rem;
        }
        .control-row:last-child { margin-bottom: 0; }
        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
            font-weight: 600;
            white-space: nowrap;
        }
        button:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }
        select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 10px;
            font-size: 0.9rem;
            cursor: pointer;
        }
        #ingredientPanel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            padding: 1.5rem;
            border-radius: 20px;
            border: 1px solid rgba(102, 126, 234, 0.3);
            z-index: 25;
            max-width: 350px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }
        #ingredientPanel.show { display: block; }
        #ingredientPanel h3 {
            font-size: 1.1rem;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #667eea, #f093fb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700;
        }
        #giphySearch {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        #giphyInput {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.5rem;
            border-radius: 8px;
            font-size: 0.85rem;
        }
        #ingredientList {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .ingredient-item {
            position: relative;
            width: 60px;
            height: 60px;
            border-radius: 10px;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        .ingredient-item:hover {
            border-color: #667eea;
            transform: scale(1.1);
        }
        .ingredient-item.active {
            border-color: #f093fb;
            box-shadow: 0 0 20px rgba(240, 147, 251, 0.6);
        }
        .ingredient-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .ingredient-remove {
            position: absolute;
            top: 2px;
            right: 2px;
            background: rgba(244, 67, 54, 0.95);
            border: none;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            font-size: 12px;
            cursor: pointer;
            display: none;
            padding: 0;
            line-height: 20px;
            font-weight: bold;
        }
        .ingredient-item:hover .ingredient-remove { display: block; }
        .ingredient-config {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        .ingredient-config h4 {
            font-size: 0.9rem;
            margin-bottom: 0.75rem;
            color: #f093fb;
        }
        .config-item {
            margin-bottom: 0.75rem;
        }
        .config-item label {
            display: block;
            font-size: 0.8rem;
            margin-bottom: 0.25rem;
            opacity: 0.8;
        }
        .config-item select {
            width: 100%;
            font-size: 0.85rem;
            padding: 0.4rem;
        }
        .upload-btn {
            width: 100%;
            font-size: 0.85rem;
            padding: 0.6rem;
        }
        .layer-indicator {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            padding: 1rem;
            border-radius: 15px;
            border: 1px solid rgba(102, 126, 234, 0.3);
            z-index: 25;
            font-size: 0.85rem;
        }
        .layer-indicator div {
            margin-bottom: 0.5rem;
        }
        .layer-indicator div:last-child { margin-bottom: 0; }
        .layer-indicator .active-layer {
            color: #f093fb;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="choreographyLayer"></div>
    <div id="ingredientLayer"></div>
    
    <div class="layer-indicator">
        <div>üé¨ Choreography: <span class="active-layer" id="choreographyName">Particles</span></div>
        <div>üé® Ingredients: <span class="active-layer" id="ingredientCount">0</span></div>
        <div>üéµ Beats: <span class="active-layer" id="beatCount">0</span></div>
    </div>
    
    <div id="ingredientPanel">
        <h3>üé® Ingredient Mixer</h3>
        <div id="giphySearch">
            <input type="text" id="giphyInput" placeholder="Search GIFs...">
            <button id="giphyBtn">üîç</button>
        </div>
        <div id="ingredientList"></div>
        <button class="upload-btn" onclick="document.getElementById('ingredientFileInput').click()">
            üìÅ Upload Images/GIFs
        </button>
        <input type="file" id="ingredientFileInput" accept="image/*,.gif" multiple style="display: none;">
        
        <div class="ingredient-config" id="ingredientConfig" style="display: none;">
            <h4>‚öôÔ∏è Ingredient Effects</h4>
            <div class="config-item">
                <label>Beat Behavior</label>
                <select id="beatBehavior">
                    <option value="sync">üéØ Sync - Triggers on beat</option>
                    <option value="align">üìç Align - Moves with beat</option>
                    <option value="contrast">‚ö° Contrast - Opposite of beat</option>
                    <option value="continuous">üåä Continuous - Ignores beat</option>
                </select>
            </div>
            <div class="config-item">
                <label>Animation Effect</label>
                <select id="animEffect">
                    <option value="bounce">üèÄ Bounce</option>
                    <option value="spin">üåÄ Spin</option>
                    <option value="pulse">üíì Pulse</option>
                    <option value="shake">üì≥ Shake</option>
                    <option value="float">üéà Float</option>
                    <option value="orbit">ü™ê Orbit</option>
                    <option value="zigzag">‚ö° ZigZag</option>
                    <option value="grow">üîç Grow/Shrink</option>
                    <option value="fade">üëª Fade In/Out</option>
                    <option value="explode">üí• Explode</option>
                    <option value="implode">üåÄ Implode</option>
                    <option value="wave">üåä Wave Motion</option>
                </select>
            </div>
            <div class="config-item">
                <label>Audio Reactivity</label>
                <select id="audioReactive">
                    <option value="bass">üîä Bass Response</option>
                    <option value="mid">üé∏ Mid Response</option>
                    <option value="treble">üéπ Treble Response</option>
                    <option value="energy">‚ö° Energy Response</option>
                    <option value="flux">üåà Spectral Flux</option>
                </select>
            </div>
            <div class="config-item">
                <label>Spawn Rate</label>
                <select id="spawnRate">
                    <option value="everybeat">Every Beat</option>
                    <option value="every2">Every 2 Beats</option>
                    <option value="every4">Every 4 Beats</option>
                    <option value="every8">Every 8 Beats</option>
                    <option value="random">Random</option>
                </select>
            </div>
            <button id="applyConfig" style="width: 100%; margin-top: 0.5rem;">Apply to Selected</button>
        </div>
    </div>
    
    <div id="ui">
        <div id="upload-area">
            <h1>üé¨ Layered Ingredient System</h1>
            <p style="font-size: 1.1rem; margin-bottom: 1rem;">Professional Audio-Reactive Choreography</p>
            <p style="opacity: 0.7;">
                Choreography Layer + Ingredient Layer + Beat-Sync Effects
            </p>
            <input type="file" id="fileInput" accept="audio/*" style="display: none;">
        </div>
    </div>
    
    <div id="controls">
        <div class="control-row">
            <button id="playBtn">‚ñ∂Ô∏è Play</button>
            <button id="ingredientsBtn">üé® Ingredients</button>
            <select id="choreographyMode">
                <option value="particles">Particle Symphony</option>
                <option value="spiral">Spiral Vortex</option>
                <option value="wave">Wave Propagation</option>
                <option value="orbits">Orbital Mechanics</option>
            </select>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');
        const choreographyLayer = document.getElementById('choreographyLayer');
        const ingredientLayer = document.getElementById('ingredientLayer');
        const uploadArea = document.getElementById('upload-area');
        const fileInput = document.getElementById('fileInput');
        const controls = document.getElementById('controls');
        const playBtn = document.getElementById('playBtn');
        const ingredientsBtn = document.getElementById('ingredientsBtn');
        const ingredientPanel = document.getElementById('ingredientPanel');
        const choreographyMode = document.getElementById('choreographyMode');
        const giphyInput = document.getElementById('giphyInput');
        const giphyBtn = document.getElementById('giphyBtn');
        const ingredientList = document.getElementById('ingredientList');
        const ingredientFileInput = document.getElementById('ingredientFileInput');
        const ingredientConfig = document.getElementById('ingredientConfig');

        let audioContext, analyser, source, audioBuffer, meydaAnalyzer;
        let isPlaying = false;
        let currentMode = 'particles';
        
        let audioFeatures = {
            bass: 0,
            mid: 0,
            treble: 0,
            energy: 0,
            spectralFlux: 0
        };

        let choreographyElements = [];
        let ingredients = [];
        let activeIngredients = [];
        let spawnedIngredients = [];
        let beatCount = 0;
        let beatHistory = [];
        let lastBeat = 0;

        // Ingredient configuration template
        class IngredientConfig {
            constructor(img, id) {
                this.img = img;
                this.id = id;
                this.beatBehavior = 'sync'; // sync, align, contrast, continuous
                this.animEffect = 'bounce'; // bounce, spin, pulse, etc.
                this.audioReactive = 'bass'; // bass, mid, treble, energy, flux
                this.spawnRate = 'everybeat'; // everybeat, every2, every4, every8, random
                this.lastSpawnBeat = 0;
            }

            shouldSpawn(currentBeat) {
                if (this.spawnRate === 'everybeat') return true;
                if (this.spawnRate === 'every2') return currentBeat % 2 === 0;
                if (this.spawnRate === 'every4') return currentBeat % 4 === 0;
                if (this.spawnRate === 'every8') return currentBeat % 8 === 0;
                if (this.spawnRate === 'random') return Math.random() > 0.7;
                return true;
            }
        }

        // Effect library - MASSIVE array of possibilities
        const EffectLibrary = {
            bounce: (element, audio) => {
                const intensity = audio * 3;
                anime({
                    targets: element,
                    translateY: [0, -100 * intensity, 0],
                    scale: [1, 1.2, 1],
                    duration: 600,
                    easing: 'easeOutBounce'
                });
            },
            
            spin: (element, audio) => {
                anime({
                    targets: element,
                    rotate: `+=${360 * (1 + audio * 2)}`,
                    duration: 500 + audio * 500,
                    easing: 'easeOutQuad'
                });
            },
            
            pulse: (element, audio) => {
                anime({
                    targets: element,
                    scale: [1, 1 + audio * 1.5, 1],
                    duration: 400,
                    easing: 'easeInOutQuad'
                });
            },
            
            shake: (element, audio) => {
                const intensity = audio * 50;
                anime({
                    targets: element,
                    translateX: [
                        { value: intensity, duration: 50 },
                        { value: -intensity, duration: 50 },
                        { value: intensity / 2, duration: 50 },
                        { value: -intensity / 2, duration: 50 },
                        { value: 0, duration: 50 }
                    ],
                    easing: 'linear'
                });
            },
            
            float: (element, audio) => {
                anime({
                    targets: element,
                    translateY: Math.sin(performance.now() / 1000) * 50 * (1 + audio),
                    translateX: Math.cos(performance.now() / 1200) * 30 * (1 + audio),
                    rotate: Math.sin(performance.now() / 2000) * 15,
                    duration: 100,
                    easing: 'linear'
                });
            },
            
            orbit: (element, audio) => {
                const cx = window.innerWidth / 2;
                const cy = window.innerHeight / 2;
                const radius = 200 + audio * 200;
                const angle = performance.now() / 1000;
                anime({
                    targets: element,
                    left: cx + Math.cos(angle) * radius + 'px',
                    top: cy + Math.sin(angle) * radius + 'px',
                    rotate: angle * 57.3,
                    duration: 50,
                    easing: 'linear'
                });
            },
            
            zigzag: (element, audio) => {
                const time = performance.now() / 500;
                anime({
                    targets: element,
                    translateX: Math.sin(time) * 100 * (1 + audio),
                    translateY: Math.cos(time * 2) * 50 * (1 + audio),
                    duration: 100,
                    easing: 'linear'
                });
            },
            
            grow: (element, audio) => {
                anime({
                    targets: element,
                    scale: 0.5 + audio * 2,
                    duration: 200,
                    easing: 'easeOutQuad'
                });
            },
            
            fade: (element, audio) => {
                anime({
                    targets: element,
                    opacity: 0.3 + audio * 0.7,
                    duration: 200,
                    easing: 'linear'
                });
            },
            
            explode: (element, audio) => {
                const angle = Math.random() * Math.PI * 2;
                const distance = audio * 300;
                anime({
                    targets: element,
                    translateX: Math.cos(angle) * distance,
                    translateY: Math.sin(angle) * distance,
                    scale: [1, 2, 0],
                    rotate: Math.random() * 720,
                    opacity: [1, 0.5, 0],
                    duration: 1000,
                    easing: 'easeOutExpo'
                });
            },
            
            implode: (element, audio) => {
                anime({
                    targets: element,
                    scale: [1, 0.1],
                    rotate: 360 * (1 + audio),
                    opacity: [1, 0],
                    duration: 800,
                    easing: 'easeInExpo'
                });
            },
            
            wave: (element, audio) => {
                const time = performance.now() / 1000;
                const wave = Math.sin(time * 2 + audio * 5) * 80;
                anime({
                    targets: element,
                    translateY: wave,
                    scale: 0.8 + Math.abs(wave) / 80 * 0.5,
                    duration: 100,
                    easing: 'linear'
                });
            }
        };

        // Resize
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (gl) gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // Simple background shader
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, `attribute vec2 position; void main() { gl_Position = vec4(position, 0.0, 1.0); }`);
        gl.compileShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, `
            precision highp float;
            uniform vec2 resolution;
            uniform float time, bass, mid, treble;
            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy;
                vec2 center = uv - 0.5;
                float dist = length(center);
                float bg = sin(dist * 10.0 - time + bass * 5.0) * 0.5 + 0.5;
                bg *= 0.08;
                vec3 col = vec3(bg) * vec3(0.4, 0.3, 0.8);
                gl_FragColor = vec4(col, 1.0);
            }
        `);
        gl.compileShader(fragmentShader);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const uniforms = {
            resolution: gl.getUniformLocation(program, 'resolution'),
            time: gl.getUniformLocation(program, 'time'),
            bass: gl.getUniformLocation(program, 'bass'),
            mid: gl.getUniformLocation(program, 'mid'),
            treble: gl.getUniformLocation(program, 'treble')
        };

        // Simplified choreographies (from previous version)
        function clearChoreography() {
            choreographyElements.forEach(el => el.remove());
            choreographyElements = [];
        }

        function initParticles() {
            clearChoreography();
            for (let i = 0; i < 50; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                p.style.left = Math.random() * window.innerWidth + 'px';
                p.style.top = Math.random() * window.innerHeight + 'px';
                choreographyLayer.appendChild(p);
                choreographyElements.push(p);
            }
        }

        function updateParticles() {
            choreographyElements.forEach((p, i) => {
                const freq = i % 3 === 0 ? audioFeatures.bass : i % 3 === 1 ? audioFeatures.mid : audioFeatures.treble;
                anime({ targets: p, scale: 0.5 + freq * 1.5, opacity: 0.3 + freq * 0.7, duration: 100, easing: 'linear' });
            });
        }

        const modes = {
            particles: { init: initParticles, update: updateParticles },
            spiral: { init: initParticles, update: updateParticles },
            wave: { init: initParticles, update: updateParticles },
            orbits: { init: initParticles, update: updateParticles }
        };

        choreographyMode.addEventListener('change', (e) => {
            currentMode = e.target.value;
            document.getElementById('choreographyName').textContent = e.target.options[e.target.selectedIndex].text;
            modes[currentMode].init();
        });

        // Ingredient management
        giphyBtn.addEventListener('click', async () => {
            const query = giphyInput.value.trim();
            if (!query) return;
            try {
                const response = await fetch(`https://api.giphy.com/v1/gifs/search?api_key=sXpGFDGZs0Dv1mmNFvYaGUvYwKX0PWIh&q=${encodeURIComponent(query)}&limit=10&rating=g`);
                const data = await response.json();
                data.data.forEach(gif => addIngredient(gif.images.fixed_height_small.url, gif.id));
                giphyInput.value = '';
            } catch (err) {
                console.error('Giphy search failed:', err);
            }
        });

        giphyInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') giphyBtn.click();
        });

        ingredientFileInput.addEventListener('change', (e) => {
            Array.from(e.target.files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => addIngredient(e.target.result, file.name);
                reader.readAsDataURL(file);
            });
        });

        function addIngredient(url, id) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                const config = new IngredientConfig(img, id);
                ingredients.push(config);
                renderIngredientList();
            };
            img.src = url;
        }

        let selectedIngredient = null;

        function renderIngredientList() {
            ingredientList.innerHTML = '';
            ingredients.forEach((ing, idx) => {
                const div = document.createElement('div');
                div.className = 'ingredient-item';
                if (activeIngredients.includes(ing)) div.classList.add('active');
                
                const img = document.createElement('img');
                img.src = ing.img.src;
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'ingredient-remove';
                removeBtn.textContent = '√ó';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    ingredients.splice(idx, 1);
                    activeIngredients = activeIngredients.filter(i => i !== ing);
                    renderIngredientList();
                };
                
                div.appendChild(img);
                div.appendChild(removeBtn);
                
                div.onclick = () => {
                    const index = activeIngredients.indexOf(ing);
                    if (index > -1) {
                        activeIngredients.splice(index, 1);
                    } else {
                        activeIngredients.push(ing);
                    }
                    selectedIngredient = ing;
                    ingredientConfig.style.display = 'block';
                    renderIngredientList();
                };
                
                ingredientList.appendChild(div);
            });
            document.getElementById('ingredientCount').textContent = activeIngredients.length;
        }

        // Apply config to selected ingredient
        document.getElementById('applyConfig').addEventListener('click', () => {
            if (selectedIngredient) {
                selectedIngredient.beatBehavior = document.getElementById('beatBehavior').value;
                selectedIngredient.animEffect = document.getElementById('animEffect').value;
                selectedIngredient.audioReactive = document.getElementById('audioReactive').value;
                selectedIngredient.spawnRate = document.getElementById('spawnRate').value;
                console.log('‚úÖ Config applied:', selectedIngredient);
            }
        });

        // Spawn ingredient with configuration
        function spawnIngredient(config, onBeat = false) {
            const container = document.createElement('div');
            container.className = 'ingredient';
            container.style.width = '100px';
            container.style.height = '100px';
            container.style.left = (Math.random() * (window.innerWidth - 100)) + 'px';
            container.style.top = (Math.random() * (window.innerHeight - 100)) + 'px';
            container.style.opacity = '0';
            
            const img = document.createElement('img');
            img.src = config.img.src;
            container.appendChild(img);
            
            ingredientLayer.appendChild(container);
            
            const spawned = {
                element: container,
                config: config,
                age: 0,
                maxAge: 100,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2
            };
            
            spawnedIngredients.push(spawned);
            
            // Initial entrance animation
            anime({
                targets: container,
                opacity: [0, 1],
                scale: [0, 1],
                duration: 400,
                easing: 'easeOutBack'
            });
        }

        // Update spawned ingredients with their configured effects
        function updateIngredients() {
            const toRemove = [];
            
            spawnedIngredients.forEach((spawned, idx) => {
                spawned.age++;
                
                if (spawned.age >= spawned.maxAge) {
                    toRemove.push(idx);
                    anime({
                        targets: spawned.element,
                        opacity: 0,
                        scale: 0,
                        duration: 300,
                        complete: () => spawned.element.remove()
                    });
                    return;
                }
                
                // Get audio value based on config
                const audioValue = audioFeatures[spawned.config.audioReactive] || audioFeatures.bass;
                
                // Apply effect based on beat behavior
                if (spawned.config.beatBehavior === 'continuous') {
                    // Always apply effect
                    EffectLibrary[spawned.config.animEffect](spawned.element, audioValue);
                } else if (spawned.config.beatBehavior === 'sync' && audioValue > 0.5) {
                    // Only on beat
                    EffectLibrary[spawned.config.animEffect](spawned.element, audioValue);
                } else if (spawned.config.beatBehavior === 'align') {
                    // Smooth follow
                    EffectLibrary[spawned.config.animEffect](spawned.element, audioValue * 0.7);
                } else if (spawned.config.beatBehavior === 'contrast') {
                    // Opposite
                    EffectLibrary[spawned.config.animEffect](spawned.element, 1 - audioValue);
                }
            });
            
            // Remove old ingredients
            for (let i = toRemove.length - 1; i >= 0; i--) {
                spawnedIngredients.splice(toRemove[i], 1);
            }
        }

        // Beat detection
        function detectBeat(bass) {
            const now = performance.now();
            beatHistory.push(bass);
            if (beatHistory.length > 30) beatHistory.shift();
            const avg = beatHistory.reduce((a, b) => a + b, 0) / beatHistory.length;
            const threshold = avg * 1.6;
            
            if (bass > threshold && now - lastBeat > 300) {
                lastBeat = now;
                beatCount++;
                document.getElementById('beatCount').textContent = beatCount;
                
                // Spawn ingredients on beat
                activeIngredients.forEach(config => {
                    if (config.shouldSpawn(beatCount)) {
                        spawnIngredient(config, true);
                    }
                });
                
                return true;
            }
            return false;
        }

        // Audio setup
        function setupAudio(arrayBuffer) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 4096;
            analyser.smoothingTimeConstant = 0.75;
            
            audioContext.decodeAudioData(arrayBuffer, (buffer) => {
                audioBuffer = buffer;
                uploadArea.classList.add('hidden');
                controls.classList.add('show');
                modes[currentMode].init();
            });
        }

        function play() {
            if (!audioBuffer) return;
            
            if (isPlaying) {
                if (source) source.stop();
                isPlaying = false;
                playBtn.textContent = '‚ñ∂Ô∏è Play';
                if (meydaAnalyzer) meydaAnalyzer.stop();
                return;
            }
            
            source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(analyser);
            analyser.connect(audioContext.destination);
            
            if (typeof Meyda !== 'undefined' && !meydaAnalyzer) {
                meydaAnalyzer = Meyda.createMeydaAnalyzer({
                    audioContext: audioContext,
                    source: source,
                    bufferSize: 2048,
                    featureExtractors: ['rms', 'energy', 'spectralFlux'],
                    callback: (features) => {
                        audioFeatures.energy = features.energy || 0;
                        audioFeatures.spectralFlux = features.spectralFlux || 0;
                    }
                });
                meydaAnalyzer.start();
            }
            
            source.start();
            isPlaying = true;
            playBtn.textContent = '‚è∏Ô∏è Pause';
            
            source.onended = () => {
                isPlaying = false;
                playBtn.textContent = '‚ñ∂Ô∏è Play';
                if (meydaAnalyzer) {
                    meydaAnalyzer.stop();
                    meydaAnalyzer = null;
                }
            };
        }

        playBtn.addEventListener('click', play);
        ingredientsBtn.addEventListener('click', () => ingredientPanel.classList.toggle('show'));

        // Main render loop
        function render() {
            const dataArray = new Uint8Array(analyser ? analyser.frequencyBinCount : 256);
            if (analyser) analyser.getByteFrequencyData(dataArray);
            
            audioFeatures.bass = dataArray.slice(0, 30).reduce((a, b) => a + b, 0) / 30 / 255;
            audioFeatures.mid = dataArray.slice(30, 120).reduce((a, b) => a + b, 0) / 90 / 255;
            audioFeatures.treble = dataArray.slice(120, 256).reduce((a, b) => a + b, 0) / 136 / 255;
            
            if (isPlaying) {
                detectBeat(audioFeatures.bass);
            }
            
            // Render background
            gl.useProgram(program);
            const posLoc = gl.getAttribLocation(program, 'position');
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
            gl.uniform1f(uniforms.time, performance.now() / 1000);
            gl.uniform1f(uniforms.bass, audioFeatures.bass);
            gl.uniform1f(uniforms.mid, audioFeatures.mid);
            gl.uniform1f(uniforms.treble, audioFeatures.treble);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            // Update choreography
            if (isPlaying && modes[currentMode]) {
                modes[currentMode].update();
            }
            
            // Update ingredients
            updateIngredients();
            
            requestAnimationFrame(render);
        }
        render();

        // File handling
        uploadArea.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) {
                const reader = new FileReader();
                reader.onload = (e) => setupAudio(e.target.result);
                reader.readAsArrayBuffer(e.target.files[0]);
            }
        });
        uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.style.borderColor = '#667eea'; });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('audio/')) {
                const reader = new FileReader();
                reader.onload = (e) => setupAudio(e.target.result);
                reader.readAsArrayBuffer(file);
            }
        });
    </script>
</body>
</html>
