<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anime.js Music Director - REVOLUTIONARY</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/meyda/5.6.0/meyda.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #animeLayer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        .particle {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #f093fb);
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
        }
        .shape {
            position: absolute;
            transform-origin: center;
            filter: drop-shadow(0 0 20px currentColor);
        }
        .text-element {
            position: absolute;
            font-size: 80px;
            font-weight: 900;
            background: linear-gradient(135deg, #667eea, #f093fb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 40px rgba(102, 126, 234, 0.6);
        }
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
        }
        #upload-area {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border: 3px dashed rgba(102, 126, 234, 0.5);
            border-radius: 25px;
            padding: 4rem 5rem;
            text-align: center;
            pointer-events: all;
            cursor: pointer;
            transition: all 0.4s;
        }
        #upload-area:hover { 
            border-color: #667eea; 
            background: rgba(102, 126, 234, 0.15);
            transform: scale(1.02);
        }
        #upload-area.hidden { display: none; }
        h1 { 
            font-size: 2.5rem; 
            margin-bottom: 1rem; 
            background: linear-gradient(135deg, #667eea, #764ba2, #f093fb);
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent;
            font-weight: 800;
        }
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            padding: 1.5rem;
            border-radius: 25px;
            border: 1px solid rgba(102, 126, 234, 0.3);
            display: none;
            z-index: 20;
        }
        #controls.show { display: block; }
        .control-row {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1rem;
        }
        .control-row:last-child { margin-bottom: 0; }
        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
            font-weight: 600;
        }
        button:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }
        select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 10px;
            font-size: 0.9rem;
            cursor: pointer;
        }
        #analysisPanel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            padding: 1.5rem;
            border-radius: 20px;
            border: 1px solid rgba(102, 126, 234, 0.3);
            z-index: 25;
            max-width: 320px;
            display: none;
        }
        #analysisPanel.show { display: block; }
        #analysisPanel h3 {
            font-size: 1.1rem;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #667eea, #f093fb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700;
        }
        .analysis-item {
            margin-bottom: 0.75rem;
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
        .analysis-value {
            font-weight: 600;
            color: #667eea;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="animeLayer"></div>
    
    <div id="analysisPanel">
        <h3>üéµ Audio Analysis</h3>
        <div class="analysis-item">
            <span>Bass</span>
            <span class="analysis-value" id="bassValue">0%</span>
        </div>
        <div class="analysis-item">
            <span>Mid</span>
            <span class="analysis-value" id="midValue">0%</span>
        </div>
        <div class="analysis-item">
            <span>Treble</span>
            <span class="analysis-value" id="trebleValue">0%</span>
        </div>
        <div class="analysis-item">
            <span>Energy</span>
            <span class="analysis-value" id="energyValue">0%</span>
        </div>
        <div class="analysis-item">
            <span>Spectral Flux</span>
            <span class="analysis-value" id="fluxValue">0</span>
        </div>
    </div>
    
    <div id="ui">
        <div id="upload-area">
            <h1>üé¨ Anime.js Music Director</h1>
            <p style="font-size: 1.1rem; margin-bottom: 1rem;">Revolutionary Audio-Reactive Choreography</p>
            <p style="opacity: 0.7;">
                Using Anime.js in ways never seen before<br>
                Real-time audio ‚Üí Animated 3D objects ‚Üí Beat-synchronized choreography
            </p>
            <input type="file" id="fileInput" accept="audio/*" style="display: none;">
        </div>
    </div>
    
    <div id="controls">
        <div class="control-row">
            <button id="playBtn">‚ñ∂Ô∏è Play</button>
            <button id="recordBtn">‚è∫Ô∏è Record</button>
            <button id="downloadBtn" style="display:none;">üíæ Download</button>
            <button id="analysisBtn">üéµ Analysis</button>
            <select id="choreographyMode">
                <option value="particles">Particle Symphony</option>
                <option value="shapes">Geometric Dance</option>
                <option value="text">Typography Explosion</option>
                <option value="orbits">Orbital Mechanics</option>
                <option value="morph">Morphing Shapes</option>
                <option value="swarm">Swarm Intelligence</option>
                <option value="spiral">Spiral Vortex</option>
                <option value="wave">Wave Propagation</option>
            </select>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');
        const animeLayer = document.getElementById('animeLayer');
        const uploadArea = document.getElementById('upload-area');
        const fileInput = document.getElementById('fileInput');
        const controls = document.getElementById('controls');
        const playBtn = document.getElementById('playBtn');
        const recordBtn = document.getElementById('recordBtn');
        const analysisBtn = document.getElementById('analysisBtn');
        const analysisPanel = document.getElementById('analysisPanel');
        const choreographyMode = document.getElementById('choreographyMode');

        let audioContext, analyser, source, audioBuffer, meydaAnalyzer;
        let isPlaying = false;
        let mediaRecorder, recordedChunks = [];
        let startTime = 0;
        let currentMode = 'particles';
        
        let audioFeatures = {
            bass: 0,
            mid: 0,
            treble: 0,
            energy: 0,
            spectralFlux: 0,
            rms: 0,
            spectralCentroid: 0
        };

        let animeElements = [];
        let beatHistory = [];
        let lastBeat = 0;

        // Resize
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (gl) gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // Simple background shader
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, `
            attribute vec2 position;
            void main() { gl_Position = vec4(position, 0.0, 1.0); }
        `);
        gl.compileShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, `
            precision highp float;
            uniform vec2 resolution;
            uniform float time;
            uniform float bass, mid, treble;
            
            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy;
                vec2 center = uv - 0.5;
                float dist = length(center);
                
                float bg = sin(dist * 10.0 - time + bass * 5.0) * 0.5 + 0.5;
                bg *= 0.1; // Subtle background
                
                vec3 col = vec3(bg) * vec3(0.4, 0.3, 0.8);
                gl_FragColor = vec4(col, 1.0);
            }
        `);
        gl.compileShader(fragmentShader);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const uniforms = {
            resolution: gl.getUniformLocation(program, 'resolution'),
            time: gl.getUniformLocation(program, 'time'),
            bass: gl.getUniformLocation(program, 'bass'),
            mid: gl.getUniformLocation(program, 'mid'),
            treble: gl.getUniformLocation(program, 'treble')
        };

        // ==========================================
        // REVOLUTIONARY ANIME.JS CHOREOGRAPHIES
        // ==========================================

        function clearAnimeElements() {
            animeElements.forEach(el => el.remove());
            animeElements = [];
        }

        // 1. PARTICLE SYMPHONY - Particles that dance to frequency bands
        function initParticleSymphony() {
            clearAnimeElements();
            const count = 100;
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.width = (10 + Math.random() * 30) + 'px';
                particle.style.height = particle.style.width;
                particle.style.left = Math.random() * window.innerWidth + 'px';
                particle.style.top = Math.random() * window.innerHeight + 'px';
                particle.style.opacity = '0';
                animeLayer.appendChild(particle);
                animeElements.push(particle);
            }
        }

        function updateParticleSymphony() {
            animeElements.forEach((particle, i) => {
                // Each particle responds to different frequency
                const freq = i % 3 === 0 ? audioFeatures.bass : 
                            i % 3 === 1 ? audioFeatures.mid : 
                            audioFeatures.treble;
                
                const scale = 0.5 + freq * 2;
                const opacity = 0.3 + freq * 0.7;
                
                anime({
                    targets: particle,
                    scale: scale,
                    opacity: opacity,
                    rotate: freq * 360,
                    duration: 100,
                    easing: 'easeOutQuad'
                });
            });
        }

        // 2. GEOMETRIC DANCE - SVG shapes morph with music
        function initGeometricDance() {
            clearAnimeElements();
            const shapes = ['‚¨ü', '‚óÜ', '‚¨¢', '‚ñ≤', '‚óè', '‚ñ†'];
            const count = 30;
            for (let i = 0; i < count; i++) {
                const shape = document.createElement('div');
                shape.className = 'shape';
                shape.textContent = shapes[i % shapes.length];
                shape.style.fontSize = (40 + Math.random() * 60) + 'px';
                shape.style.left = Math.random() * window.innerWidth + 'px';
                shape.style.top = Math.random() * window.innerHeight + 'px';
                shape.style.color = `hsl(${Math.random() * 360}, 80%, 60%)`;
                animeLayer.appendChild(shape);
                animeElements.push(shape);
            }
        }

        function updateGeometricDance() {
            animeElements.forEach((shape, i) => {
                const energy = audioFeatures.energy;
                const flux = audioFeatures.spectralFlux;
                
                anime({
                    targets: shape,
                    translateX: (Math.random() - 0.5) * energy * 200,
                    translateY: (Math.random() - 0.5) * energy * 200,
                    scale: 1 + flux * 2,
                    rotate: energy * 180,
                    duration: 300,
                    easing: 'easeOutElastic(1, .6)'
                });
            });
        }

        // 3. TYPOGRAPHY EXPLOSION - Text explodes on beats
        function initTypographyExplosion() {
            clearAnimeElements();
            const words = ['BASS', 'DROP', 'BEAT', 'FLOW', 'WAVE', 'PULSE'];
            words.forEach((word, i) => {
                const text = document.createElement('div');
                text.className = 'text-element';
                text.textContent = word;
                text.style.left = '50%';
                text.style.top = '50%';
                text.style.transform = 'translate(-50%, -50%)';
                text.style.opacity = '0';
                animeLayer.appendChild(text);
                animeElements.push(text);
            });
        }

        function updateTypographyExplosion() {
            // Trigger on beats
            const bass = audioFeatures.bass;
            if (bass > 0.5) {
                const randomText = animeElements[Math.floor(Math.random() * animeElements.length)];
                anime({
                    targets: randomText,
                    scale: [0, 3],
                    opacity: [1, 0],
                    rotate: anime.random(-45, 45),
                    translateX: anime.random(-300, 300),
                    translateY: anime.random(-300, 300),
                    duration: 1000,
                    easing: 'easeOutExpo'
                });
            }
        }

        // 4. ORBITAL MECHANICS - Objects orbit based on audio
        function initOrbitalMechanics() {
            clearAnimeElements();
            const layers = 5;
            const perLayer = 8;
            for (let layer = 0; layer < layers; layer++) {
                for (let i = 0; i < perLayer; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.width = (15 - layer * 2) + 'px';
                    particle.style.height = particle.style.width;
                    particle.dataset.layer = layer;
                    particle.dataset.index = i;
                    animeLayer.appendChild(particle);
                    animeElements.push(particle);
                }
            }
        }

        function updateOrbitalMechanics() {
            const cx = window.innerWidth / 2;
            const cy = window.innerHeight / 2;
            
            animeElements.forEach((particle) => {
                const layer = parseInt(particle.dataset.layer);
                const index = parseInt(particle.dataset.index);
                const perLayer = 8;
                
                const freq = layer === 0 ? audioFeatures.bass :
                            layer === 1 ? audioFeatures.mid :
                            audioFeatures.treble;
                
                const radius = 100 + layer * 80 + freq * 100;
                const angle = (index / perLayer) * Math.PI * 2 + performance.now() / (1000 + layer * 200);
                
                const x = cx + Math.cos(angle) * radius;
                const y = cy + Math.sin(angle) * radius;
                
                anime({
                    targets: particle,
                    left: x + 'px',
                    top: y + 'px',
                    scale: 0.5 + freq,
                    opacity: 0.5 + freq * 0.5,
                    duration: 50,
                    easing: 'linear'
                });
            });
        }

        // 5. MORPHING SHAPES - Bezier path morphing
        function initMorphingShapes() {
            clearAnimeElements();
            const count = 15;
            for (let i = 0; i < count; i++) {
                const shape = document.createElement('div');
                shape.className = 'particle';
                shape.style.width = (30 + Math.random() * 40) + 'px';
                shape.style.height = shape.style.width;
                shape.style.borderRadius = Math.random() > 0.5 ? '50%' : '0%';
                animeLayer.appendChild(shape);
                animeElements.push(shape);
            }
        }

        function updateMorphingShapes() {
            animeElements.forEach((shape, i) => {
                const energy = audioFeatures.energy;
                const flux = audioFeatures.spectralFlux;
                
                anime({
                    targets: shape,
                    translateX: Math.sin(performance.now() / 1000 + i) * 300 * energy,
                    translateY: Math.cos(performance.now() / 1000 + i) * 300 * energy,
                    scale: [1, 1 + flux * 2],
                    borderRadius: energy > 0.5 ? '50%' : '0%',
                    rotate: energy * 360,
                    duration: 200,
                    easing: 'easeInOutQuad'
                });
            });
        }

        // 6. SWARM INTELLIGENCE - Flocking behavior
        function initSwarmIntelligence() {
            clearAnimeElements();
            const count = 80;
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.width = '8px';
                particle.style.height = '8px';
                particle.dataset.vx = (Math.random() - 0.5) * 5;
                particle.dataset.vy = (Math.random() - 0.5) * 5;
                animeLayer.appendChild(particle);
                animeElements.push(particle);
            }
        }

        function updateSwarmIntelligence() {
            const cx = window.innerWidth / 2;
            const cy = window.innerHeight / 2;
            const energy = audioFeatures.energy;
            
            animeElements.forEach((particle) => {
                const x = parseFloat(particle.style.left) || Math.random() * window.innerWidth;
                const y = parseFloat(particle.style.top) || Math.random() * window.innerHeight;
                let vx = parseFloat(particle.dataset.vx);
                let vy = parseFloat(particle.dataset.vy);
                
                // Attract to center based on energy
                const dx = cx - x;
                const dy = cy - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                vx += (dx / dist) * energy * 0.5;
                vy += (dy / dist) * energy * 0.5;
                
                // Add turbulence from flux
                vx += (Math.random() - 0.5) * audioFeatures.spectralFlux * 2;
                vy += (Math.random() - 0.5) * audioFeatures.spectralFlux * 2;
                
                // Damping
                vx *= 0.95;
                vy *= 0.95;
                
                particle.dataset.vx = vx;
                particle.dataset.vy = vy;
                
                anime({
                    targets: particle,
                    left: (x + vx) + 'px',
                    top: (y + vy) + 'px',
                    scale: 0.5 + energy,
                    duration: 50,
                    easing: 'linear'
                });
            });
        }

        // 7. SPIRAL VORTEX - Logarithmic spiral
        function initSpiralVortex() {
            clearAnimeElements();
            const count = 100;
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.width = (5 + i / 10) + 'px';
                particle.style.height = particle.style.width;
                particle.dataset.index = i;
                animeLayer.appendChild(particle);
                animeElements.push(particle);
            }
        }

        function updateSpiralVortex() {
            const cx = window.innerWidth / 2;
            const cy = window.innerHeight / 2;
            const bass = audioFeatures.bass;
            const time = performance.now() / 1000;
            
            animeElements.forEach((particle) => {
                const i = parseInt(particle.dataset.index);
                const angle = i * 0.5 + time * (1 + bass * 2);
                const radius = i * 3 + bass * 100;
                
                const x = cx + Math.cos(angle) * radius;
                const y = cy + Math.sin(angle) * radius;
                
                anime({
                    targets: particle,
                    left: x + 'px',
                    top: y + 'px',
                    opacity: 1 - (i / 100),
                    scale: 0.5 + bass,
                    duration: 50,
                    easing: 'linear'
                });
            });
        }

        // 8. WAVE PROPAGATION - Ripple effect
        function initWavePropagation() {
            clearAnimeElements();
            const rows = 12;
            const cols = 20;
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.width = '15px';
                    particle.style.height = '15px';
                    particle.dataset.row = row;
                    particle.dataset.col = col;
                    animeLayer.appendChild(particle);
                    animeElements.push(particle);
                }
            }
        }

        function updateWavePropagation() {
            const time = performance.now() / 500;
            const energy = audioFeatures.energy;
            const cols = 20;
            
            animeElements.forEach((particle) => {
                const row = parseInt(particle.dataset.row);
                const col = parseInt(particle.dataset.col);
                
                const x = (window.innerWidth / cols) * col + window.innerWidth / cols / 2;
                const baseY = (window.innerHeight / 12) * row + 50;
                const wave = Math.sin(col * 0.5 - time + energy * 5) * 50 * energy;
                const y = baseY + wave;
                
                anime({
                    targets: particle,
                    left: x + 'px',
                    top: y + 'px',
                    scale: 0.5 + Math.abs(wave) / 50,
                    opacity: 0.3 + energy * 0.7,
                    duration: 100,
                    easing: 'easeOutQuad'
                });
            });
        }

        // Mode initialization
        const modes = {
            particles: { init: initParticleSymphony, update: updateParticleSymphony },
            shapes: { init: initGeometricDance, update: updateGeometricDance },
            text: { init: initTypographyExplosion, update: updateTypographyExplosion },
            orbits: { init: initOrbitalMechanics, update: updateOrbitalMechanics },
            morph: { init: initMorphingShapes, update: updateMorphingShapes },
            swarm: { init: initSwarmIntelligence, update: updateSwarmIntelligence },
            spiral: { init: initSpiralVortex, update: updateSpiralVortex },
            wave: { init: initWavePropagation, update: updateWavePropagation }
        };

        choreographyMode.addEventListener('change', (e) => {
            currentMode = e.target.value;
            modes[currentMode].init();
        });

        // Audio setup
        function setupAudio(arrayBuffer) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 4096;
            analyser.smoothingTimeConstant = 0.75;
            
            audioContext.decodeAudioData(arrayBuffer, (buffer) => {
                audioBuffer = buffer;
                uploadArea.classList.add('hidden');
                controls.classList.add('show');
                analysisPanel.classList.add('show');
                
                // Initialize first mode
                modes[currentMode].init();
            });
        }

        function play() {
            if (!audioBuffer) return;
            
            if (isPlaying) {
                if (source) source.stop();
                isPlaying = false;
                playBtn.textContent = '‚ñ∂Ô∏è Play';
                if (meydaAnalyzer) meydaAnalyzer.stop();
                return;
            }
            
            source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(analyser);
            analyser.connect(audioContext.destination);
            
            if (typeof Meyda !== 'undefined' && !meydaAnalyzer) {
                meydaAnalyzer = Meyda.createMeydaAnalyzer({
                    audioContext: audioContext,
                    source: source,
                    bufferSize: 2048,
                    featureExtractors: ['rms', 'energy', 'spectralCentroid', 'spectralFlux'],
                    callback: (features) => {
                        audioFeatures.rms = features.rms || 0;
                        audioFeatures.energy = features.energy || 0;
                        audioFeatures.spectralCentroid = features.spectralCentroid || 0;
                        audioFeatures.spectralFlux = features.spectralFlux || 0;
                        
                        document.getElementById('energyValue').textContent = (features.energy * 100).toFixed(0) + '%';
                        document.getElementById('fluxValue').textContent = (features.spectralFlux * 10).toFixed(2);
                    }
                });
                meydaAnalyzer.start();
            }
            
            source.start();
            isPlaying = true;
            playBtn.textContent = '‚è∏Ô∏è Pause';
            startTime = audioContext.currentTime;
            
            source.onended = () => {
                isPlaying = false;
                playBtn.textContent = '‚ñ∂Ô∏è Play';
                if (meydaAnalyzer) {
                    meydaAnalyzer.stop();
                    meydaAnalyzer = null;
                }
            };
        }

        playBtn.addEventListener('click', play);
        analysisBtn.addEventListener('click', () => analysisPanel.classList.toggle('show'));

        // Main render loop
        function render() {
            const dataArray = new Uint8Array(analyser ? analyser.frequencyBinCount : 256);
            if (analyser) analyser.getByteFrequencyData(dataArray);
            
            audioFeatures.bass = dataArray.slice(0, 30).reduce((a, b) => a + b, 0) / 30 / 255;
            audioFeatures.mid = dataArray.slice(30, 120).reduce((a, b) => a + b, 0) / 90 / 255;
            audioFeatures.treble = dataArray.slice(120, 256).reduce((a, b) => a + b, 0) / 136 / 255;
            
            document.getElementById('bassValue').textContent = (audioFeatures.bass * 100).toFixed(0) + '%';
            document.getElementById('midValue').textContent = (audioFeatures.mid * 100).toFixed(0) + '%';
            document.getElementById('trebleValue').textContent = (audioFeatures.treble * 100).toFixed(0) + '%';
            
            // Render background
            gl.useProgram(program);
            const posLoc = gl.getAttribLocation(program, 'position');
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
            gl.uniform1f(uniforms.time, performance.now() / 1000);
            gl.uniform1f(uniforms.bass, audioFeatures.bass);
            gl.uniform1f(uniforms.mid, audioFeatures.mid);
            gl.uniform1f(uniforms.treble, audioFeatures.treble);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            // Update anime choreography
            if (isPlaying && modes[currentMode]) {
                modes[currentMode].update();
            }
            
            requestAnimationFrame(render);
        }
        render();

        // File handling
        uploadArea.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) {
                const reader = new FileReader();
                reader.onload = (e) => setupAudio(e.target.result);
                reader.readAsArrayBuffer(e.target.files[0]);
            }
        });
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = '#667eea';
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('audio/')) {
                const reader = new FileReader();
                reader.onload = (e) => setupAudio(e.target.result);
                reader.readAsArrayBuffer(file);
            }
        });
    </script>
</body>
</html>
